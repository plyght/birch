import {
  loadConfig
} from "../chunk-QXHN25N3.js";
import {
  getImportCode,
  toImportPath
} from "../chunk-CXA4JO4Z.js";
import "../chunk-2HXTGJBI.js";
import {
  getGitTimestamp
} from "../chunk-VUEZTR2H.js";
import {
  ValidationError,
  createCore,
  findConfigFile,
  mdxLoaderGlob,
  validate
} from "../chunk-2AQRQXSO.js";
import {
  fumaMatter
} from "../chunk-VWJKRQZR.js";

// src/next/index.ts
import * as path3 from "path";

// src/next/file-cache.ts
import { LRUCache } from "lru-cache";
import fs from "fs/promises";
import path from "path";
var map = new LRUCache({
  max: 100
});
function toFullPath(file) {
  if (path.isAbsolute(file)) {
    return path.relative(process.cwd(), file);
  }
  return file;
}
async function readFileWithCache(file) {
  const fullPath = toFullPath(file);
  const cached = map.get(fullPath);
  if (cached) return cached;
  const read = fs.readFile(fullPath).then((s) => s.toString());
  map.set(fullPath, read);
  return read;
}
function removeFileCache(file) {
  map.delete(toFullPath(file));
}

// src/plugins/next.ts
import * as path2 from "path";
import { createHash } from "crypto";
import { load } from "js-yaml";
function next() {
  let config;
  let shouldEmitOnChange = false;
  return {
    name: "next",
    config(v) {
      config = v;
      shouldEmitOnChange = config.collectionList.some((collection) => {
        return collection.type === "doc" && collection.async || collection.type === "docs" || collection.type === "meta";
      });
    },
    configureServer(server) {
      if (!server.watcher) return;
      server.watcher.on("all", async (event) => {
        if (event === "change" && !shouldEmitOnChange) return;
        await this.core.emitAndWrite({
          filterPlugin: (plugin) => plugin.name === "next"
        });
      });
    },
    async emit() {
      return [
        {
          path: "index.ts",
          content: await indexFile(this.configPath, config, {
            relativeTo: this.outDir
          })
        }
      ];
    }
  };
}
async function indexFile(configPath, config, importPath) {
  let asyncInit = false;
  const lines = [
    getImportCode({
      type: "named",
      names: ["_runtime"],
      specifier: "fumadocs-mdx/runtime/next"
    }),
    getImportCode({
      type: "namespace",
      specifier: toImportPath(configPath, importPath),
      name: "_source"
    })
  ];
  function getDocEntries(collection, files) {
    return files.map((file, i) => {
      const importId = `d_${collection.name}_${i}`;
      const params = [`collection=${collection.name}`];
      lines.unshift(
        getImportCode({
          type: "namespace",
          name: importId,
          specifier: `${toImportPath(file.fullPath, importPath)}?${params.join("&")}`
        })
      );
      return `{ info: ${JSON.stringify(file)}, data: ${importId} }`;
    });
  }
  async function getMetaEntries(collection, files) {
    const items = files.map(async (file) => {
      const source = await readFileWithCache(file.fullPath).catch(() => "");
      let data = source.length === 0 ? {} : parseMetaEntry(file.fullPath, source);
      if (collection?.schema) {
        data = await validate(
          collection.schema,
          data,
          {
            source,
            path: file.fullPath
          },
          `invalid data in ${file.fullPath}`
        );
      }
      return JSON.stringify({
        info: file,
        data
      });
    });
    return Promise.all(items);
  }
  async function getAsyncEntries(collection, files) {
    if (!asyncInit) {
      lines.unshift(
        getImportCode({
          type: "named",
          specifier: "fumadocs-mdx/runtime/async",
          names: ["_runtimeAsync", "buildConfig"]
        }),
        "const _sourceConfig = buildConfig(_source)",
        getImportCode({
          type: "default",
          name: "path",
          specifier: "node:path"
        })
      );
      asyncInit = true;
    }
    const entries = files.map(async (file) => {
      const content = await readFileWithCache(file.fullPath).catch(() => "");
      const parsed = fumaMatter(content);
      let data = parsed.data;
      if (collection.schema) {
        data = await validate(
          collection.schema,
          parsed.data,
          { path: file.fullPath, source: parsed.content },
          `invalid frontmatter in ${file.fullPath}`
        );
      }
      let lastModified;
      if (config.global?.lastModifiedTime === "git") {
        lastModified = await getGitTimestamp(file.fullPath);
      }
      const hash = createHash("md5").update(content).digest("hex");
      const infoStr = [];
      for (const [k, v] of Object.entries({ ...file, hash })) {
        infoStr.push(`${k}: ${JSON.stringify(v)}`);
      }
      infoStr.push(
        `absolutePath: path.resolve(${JSON.stringify(file.fullPath)})`
      );
      return `{ info: { ${infoStr.join(", ")} }, lastModified: ${JSON.stringify(lastModified)}, data: ${JSON.stringify(data)} }`;
    });
    return Promise.all(entries);
  }
  const declares = config.collectionList.map(async (collection) => {
    const k = collection.name;
    if (collection.type === "docs") {
      const docs = await globCollectionFiles(collection.docs);
      const metas = await globCollectionFiles(collection.meta);
      const metaEntries = (await getMetaEntries(collection.meta, metas)).join(
        ", "
      );
      if (collection.docs.async) {
        const docsEntries2 = (await getAsyncEntries(collection.docs, docs)).join(
          ", "
        );
        return `export const ${k} = _runtimeAsync.docs<typeof _source.${k}>([${docsEntries2}], [${metaEntries}], "${k}", _sourceConfig)`;
      }
      const docsEntries = getDocEntries(collection.docs, docs).join(", ");
      return `export const ${k} = _runtime.docs<typeof _source.${k}>([${docsEntries}], [${metaEntries}])`;
    }
    const files = await globCollectionFiles(collection);
    if (collection.type === "meta") {
      return `export const ${k} = _runtime.meta<typeof _source.${k}>([${(await getMetaEntries(collection, files)).join(", ")}]);`;
    }
    if (collection.async) {
      return `export const ${k} = _runtimeAsync.doc<typeof _source.${k}>([${(await getAsyncEntries(collection, files)).join(", ")}], "${k}", _sourceConfig)`;
    }
    return `export const ${k} = _runtime.doc<typeof _source.${k}>([${getDocEntries(collection, files).join(", ")}]);`;
  });
  const resolvedDeclares = await Promise.all(declares);
  return [
    `// @ts-nocheck -- skip type checking`,
    ...lines,
    ...resolvedDeclares
  ].join("\n");
}
function parseMetaEntry(file, content) {
  const extname2 = path2.extname(file);
  try {
    if (extname2 === ".json") return JSON.parse(content);
    if (extname2 === ".yaml") return load(content);
  } catch (e) {
    throw new Error(`Failed to parse meta file: ${file}.`, {
      cause: e
    });
  }
  throw new Error(`Unknown meta file format: ${extname2}, in ${file}.`);
}
async function globCollectionFiles(collection) {
  const { glob } = await import("tinyglobby");
  const files = /* @__PURE__ */ new Map();
  const dirs = Array.isArray(collection.dir) ? collection.dir : [collection.dir];
  await Promise.all(
    dirs.map(async (dir) => {
      const result = await glob(collection.patterns, {
        cwd: path2.resolve(dir)
      });
      for (const item of result) {
        if (!collection.isFileSupported(item)) continue;
        const fullPath = path2.join(dir, item);
        files.set(fullPath, {
          path: item,
          fullPath
        });
      }
    })
  );
  return Array.from(files.values());
}

// src/next/index.ts
var defaultPageExtensions = ["mdx", "md", "jsx", "js", "tsx", "ts"];
function createMDX(createOptions = {}) {
  const options = applyDefaults(createOptions);
  const isDev = process.env.NODE_ENV === "development";
  if (process.env._FUMADOCS_MDX !== "1") {
    process.env._FUMADOCS_MDX = "1";
    void init(isDev, options);
  }
  return (nextConfig = {}) => {
    const loaderOptions = {
      ...options,
      isDev
    };
    const turbopack = {
      ...nextConfig.turbopack,
      rules: {
        ...nextConfig.turbopack?.rules,
        "*.{md,mdx}": {
          loaders: [
            {
              loader: "fumadocs-mdx/loader-mdx",
              options: loaderOptions
            }
          ],
          as: "*.js"
        }
      }
    };
    return {
      ...nextConfig,
      turbopack,
      pageExtensions: nextConfig.pageExtensions ?? defaultPageExtensions,
      webpack: (config, options2) => {
        config.resolve ||= {};
        config.module ||= {};
        config.module.rules ||= [];
        config.module.rules.push({
          test: mdxLoaderGlob,
          use: [
            options2.defaultLoaders.babel,
            {
              loader: "fumadocs-mdx/loader-mdx",
              options: loaderOptions
            }
          ]
        });
        config.plugins ||= [];
        return nextConfig.webpack?.(config, options2) ?? config;
      }
    };
  };
}
async function init(dev, options) {
  const core = createNextCore(options);
  async function initOrReload() {
    await core.init({
      config: loadConfig(options.configPath, options.outDir, true)
    });
    await core.emitAndWrite();
  }
  async function devServer() {
    const { FSWatcher } = await import("chokidar");
    const watcher = new FSWatcher({
      ignoreInitial: true,
      persistent: true,
      ignored: [options.outDir]
    });
    watcher.add(options.configPath);
    for (const collection of core.getConfig().collectionList) {
      if (collection.type === "docs") {
        watcher.add(collection.docs.dir);
        watcher.add(collection.meta.dir);
      } else {
        watcher.add(collection.dir);
      }
    }
    watcher.on("ready", () => {
      console.log("[MDX] started dev server");
    });
    watcher.on("all", async (event, file) => {
      const absolutePath = path3.resolve(file);
      if (event === "change") removeFileCache(absolutePath);
      if (absolutePath === path3.resolve(options.configPath)) {
        watcher.removeAllListeners();
        await watcher.close();
        await initOrReload();
        console.log("[MDX] restarting dev server");
        await devServer();
      }
    });
    process.on("exit", () => {
      if (watcher.closed) return;
      console.log("[MDX] closing dev server");
      void watcher.close();
    });
    await core.initServer({ watcher });
  }
  await initOrReload();
  if (dev) {
    await devServer();
  }
}
async function postInstall(configPath = findConfigFile(), outDir = ".source") {
  const core = await createNextCore({
    outDir,
    configPath
  }).init({
    config: loadConfig(configPath, outDir, true)
  });
  await core.emitAndWrite();
}
function applyDefaults(options) {
  return {
    outDir: options.outDir ?? ".source",
    configPath: options.configPath ?? findConfigFile()
  };
}
function createNextCore({
  outDir,
  configPath
}) {
  const core = createCore(
    {
      environment: "next",
      outDir,
      configPath
    },
    [next()]
  );
  return {
    ...core,
    async emitAndWrite(...args) {
      try {
        await core.emitAndWrite(...args);
      } catch (err) {
        if (err instanceof ValidationError) {
          console.error(err.toStringFormatted());
        } else {
          console.error(err);
        }
      }
    }
  };
}
export {
  createMDX,
  postInstall
};
