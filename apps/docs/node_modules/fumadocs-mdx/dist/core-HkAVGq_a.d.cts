import { ProcessorOptions } from '@mdx-js/mdx';
import { StandardSchemaV1 } from '@standard-schema/spec';
import * as plugins from 'fumadocs-core/mdx-plugins';
import { Pluggable } from 'unified';
import { z } from 'zod';
import { FSWatcher } from 'chokidar';

interface ExtractedReference {
    href: string;
}
interface PostprocessOptions {
    _format: 'md' | 'mdx';
    /**
     * Properties to export from `vfile.data`
     */
    valueToExport?: string[];
    /**
     * stringify MDAST and export via `_markdown`.
     */
    includeProcessedMarkdown?: boolean;
    /**
     * store MDAST and export via `_mdast`.
     */
    includeMDAST?: boolean | {
        removePosition?: boolean;
    };
}

type ResolvePlugins = Pluggable[] | ((v: Pluggable[]) => Pluggable[]);
type DefaultMDXOptions = Omit<NonNullable<ProcessorOptions>, 'rehypePlugins' | 'remarkPlugins' | '_ctx'> & {
    rehypePlugins?: ResolvePlugins;
    remarkPlugins?: ResolvePlugins;
    /**
     * Properties to export from `vfile.data`
     */
    valueToExport?: string[];
    remarkStructureOptions?: plugins.StructureOptions | false;
    remarkHeadingOptions?: plugins.RemarkHeadingOptions;
    remarkImageOptions?: plugins.RemarkImageOptions | false;
    remarkCodeTabOptions?: plugins.RemarkCodeTabOptions | false;
    remarkNpmOptions?: plugins.RemarkNpmOptions | false;
    rehypeCodeOptions?: plugins.RehypeCodeOptions | false;
    _withoutBundler?: boolean;
};
declare function getDefaultMDXOptions({ valueToExport, rehypeCodeOptions, remarkImageOptions, remarkHeadingOptions, remarkStructureOptions, remarkCodeTabOptions, remarkNpmOptions, _withoutBundler, ...mdxOptions }: DefaultMDXOptions): ProcessorOptions;

/**
 * Zod 4 schema
 */
declare const metaSchema: z.ZodObject<{
    title: z.ZodOptional<z.ZodString>;
    pages: z.ZodOptional<z.ZodArray<z.ZodString>>;
    description: z.ZodOptional<z.ZodString>;
    root: z.ZodOptional<z.ZodBoolean>;
    defaultOpen: z.ZodOptional<z.ZodBoolean>;
    icon: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * Zod 4 schema
 */
declare const frontmatterSchema: z.ZodObject<{
    title: z.ZodString;
    description: z.ZodOptional<z.ZodString>;
    icon: z.ZodOptional<z.ZodString>;
    full: z.ZodOptional<z.ZodBoolean>;
    _openapi: z.ZodOptional<z.ZodObject<{}, z.core.$loose>>;
}, z.core.$strip>;

type CollectionSchema<Schema extends StandardSchemaV1, Context> = Schema | ((ctx: Context) => Schema);
type AnyCollection = DocsCollection | DocCollection | MetaCollection;
interface BaseCollection {
    /**
     * Directories to scan
     */
    dir: string | string[];
    /**
     * what files to include/exclude (glob patterns)
     *
     * Include all files if not specified
     */
    files?: string[];
}
interface MetaCollection<Schema extends StandardSchemaV1 = StandardSchemaV1> extends BaseCollection {
    type: 'meta';
    schema?: CollectionSchema<Schema, {
        path: string;
        source: string;
    }>;
}
interface DocCollection<Schema extends StandardSchemaV1 = StandardSchemaV1, Async extends boolean = boolean> extends BaseCollection {
    type: 'doc';
    postprocess?: Partial<PostprocessOptions>;
    mdxOptions?: ProcessorOptions;
    /**
     * Load files with async
     */
    async?: Async;
    schema?: CollectionSchema<Schema, {
        path: string;
        source: string;
    }>;
}
interface DocsCollection<DocSchema extends StandardSchemaV1 = StandardSchemaV1, MetaSchema extends StandardSchemaV1 = StandardSchemaV1, Async extends boolean = boolean> {
    type: 'docs';
    dir: string;
    docs: DocCollection<DocSchema, Async>;
    meta: MetaCollection<MetaSchema>;
}
type GlobalConfigMDXOptions = ({
    preset?: 'fumadocs';
} & DefaultMDXOptions) | ({
    preset: 'minimal';
} & ProcessorOptions);
interface GlobalConfig {
    collections?: Record<string, AnyCollection>;
    plugins?: PluginOption[];
    /**
     * Configure global MDX options
     *
     * @remarks `GlobalConfigMDXOptions`
     */
    mdxOptions?: GlobalConfigMDXOptions | (() => Promise<GlobalConfigMDXOptions>);
    /**
     * Fetch last modified time with specified version control
     * @defaultValue 'none'
     */
    lastModifiedTime?: 'git' | 'none';
    /**
     * specify a directory to access & store cache (disabled during development mode).
     *
     * The cache will never be updated, delete the cache folder to clean.
     */
    experimentalBuildCache?: string;
}
declare function defineCollections<Schema extends StandardSchemaV1 = StandardSchemaV1, Async extends boolean = false>(options: DocCollection<Schema, Async>): DocCollection<Schema, Async>;
declare function defineCollections<Schema extends StandardSchemaV1 = StandardSchemaV1>(options: MetaCollection<Schema>): MetaCollection<Schema>;
declare function defineDocs<DocSchema extends StandardSchemaV1 = typeof frontmatterSchema, MetaSchema extends StandardSchemaV1 = typeof metaSchema, Async extends boolean = false>(options: {
    /**
     * The content directory to scan files
     *
     *  @defaultValue 'content/docs'
     */
    dir?: string;
    docs?: Omit<DocCollection<DocSchema, Async>, 'dir' | 'type'>;
    meta?: Omit<MetaCollection<MetaSchema>, 'dir' | 'type'>;
}): DocsCollection<DocSchema, MetaSchema, Async>;
declare function defineConfig(config?: GlobalConfig): GlobalConfig;

interface LoadedConfig {
    collectionList: CollectionItem[];
    getCollection(name: string): CollectionItem | undefined;
    global: GlobalConfig;
    getDefaultMDXOptions(mode?: 'default' | 'remote'): Promise<ProcessorOptions>;
}
type CollectionItem = MetaCollectionItem | DocCollectionItem | DocsCollectionItem;
type PrimitiveCollectionItem<T extends DocCollection | MetaCollection> = Omit<T, 'files'> & {
    name: string;
    hasFile: (filePath: string) => boolean;
    isFileSupported: (filePath: string) => boolean;
    patterns: string[];
};
type MetaCollectionItem = PrimitiveCollectionItem<MetaCollection>;
type DocCollectionItem = PrimitiveCollectionItem<DocCollection>;
interface DocsCollectionItem extends DocsCollection {
    name: string;
    meta: MetaCollectionItem;
    docs: DocCollectionItem;
}
declare function buildConfig(config: Record<string, unknown>): LoadedConfig;

type Awaitable<T> = T | Promise<T>;
interface EmitEntry {
    /**
     * path relative to output directory
     */
    path: string;
    content: string;
}
interface PluginContext extends CoreOptions {
    core: Core;
}
interface Plugin {
    name?: string;
    /**
     * on config loaded/updated
     */
    config?: (this: PluginContext, config: LoadedConfig) => Awaitable<void | LoadedConfig>;
    /**
     * Generate files (e.g. types, index file, or JSON schemas)
     */
    emit?: (this: PluginContext) => Awaitable<EmitEntry[]>;
    /**
     * Configure Fumadocs dev server
     */
    configureServer?: (this: PluginContext, server: ServerContext) => Awaitable<void>;
}
type PluginOption = Awaitable<Plugin | Plugin[] | false>;
interface ServerContext {
    /**
     * the file watcher, by default all content files are watched, along with other files.
     *
     * make sure to filter when listening to events
     */
    watcher?: FSWatcher;
}
interface CoreOptions {
    environment: string;
    configPath: string;
    outDir: string;
}
interface EmitOptions {
    /**
     * filter the plugins to run emit
     */
    filterPlugin?: (plugin: Plugin) => boolean;
}
declare function findConfigFile(): string;
declare function createCore(options: CoreOptions, defaultPlugins?: PluginOption[]): {
    _options: CoreOptions;
    getPluginContext(): PluginContext;
    /**
     * Convenient cache store, reset when config changes
     */
    cache: Map<string, unknown>;
    init({ config: newConfig }: {
        config: Awaitable<LoadedConfig>;
    }): Promise</*elided*/ any>;
    getConfig(): LoadedConfig;
    initServer(server: ServerContext): Promise<void>;
    emitAndWrite({ filterPlugin, }?: EmitOptions): Promise<void>;
};
type Core = ReturnType<typeof createCore>;

export { type AnyCollection as A, type BaseCollection as B, type CollectionSchema as C, type DefaultMDXOptions as D, type ExtractedReference as E, type GlobalConfig as G, type LoadedConfig as L, type MetaCollection as M, type PostprocessOptions as P, type ServerContext as S, type DocCollection as a, type DocsCollection as b, defineDocs as c, defineCollections as d, defineConfig as e, frontmatterSchema as f, getDefaultMDXOptions as g, type CoreOptions as h, type Plugin as i, buildConfig as j, type EmitEntry as k, type PluginContext as l, metaSchema as m, type PluginOption as n, type EmitOptions as o, findConfigFile as p, createCore as q, type Core as r };
