"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/config/index.ts
var config_exports = {};
__export(config_exports, {
  defineCollections: () => defineCollections,
  defineConfig: () => defineConfig,
  defineDocs: () => defineDocs,
  frontmatterSchema: () => frontmatterSchema,
  getDefaultMDXOptions: () => getDefaultMDXOptions,
  metaSchema: () => metaSchema,
  remarkInclude: () => remarkInclude
});
module.exports = __toCommonJS(config_exports);

// src/config/zod-4.ts
var import_zod = require("zod");
var metaSchema = import_zod.z.object({
  title: import_zod.z.string().optional(),
  pages: import_zod.z.array(import_zod.z.string()).optional(),
  description: import_zod.z.string().optional(),
  root: import_zod.z.boolean().optional(),
  defaultOpen: import_zod.z.boolean().optional(),
  icon: import_zod.z.string().optional()
});
var frontmatterSchema = import_zod.z.object({
  title: import_zod.z.string(),
  description: import_zod.z.string().optional(),
  icon: import_zod.z.string().optional(),
  full: import_zod.z.boolean().optional(),
  // Fumadocs OpenAPI generated
  _openapi: import_zod.z.looseObject({}).optional()
});

// src/config/define.ts
function defineCollections(options) {
  return options;
}
function defineDocs(options) {
  const dir = options.dir ?? "content/docs";
  return {
    type: "docs",
    dir,
    docs: defineCollections({
      type: "doc",
      dir,
      schema: frontmatterSchema,
      ...options?.docs
    }),
    meta: defineCollections({
      type: "meta",
      dir,
      schema: metaSchema,
      ...options?.meta
    })
  };
}
function defineConfig(config = {}) {
  return config;
}

// src/loaders/mdx/preset.ts
var plugins = __toESM(require("fumadocs-core/mdx-plugins"), 1);
function pluginOption(def, options = []) {
  const list = def(Array.isArray(options) ? options : []).filter(
    Boolean
  );
  if (typeof options === "function") {
    return options(list);
  }
  return list;
}
function getDefaultMDXOptions({
  valueToExport = [],
  rehypeCodeOptions,
  remarkImageOptions,
  remarkHeadingOptions,
  remarkStructureOptions,
  remarkCodeTabOptions,
  remarkNpmOptions,
  _withoutBundler = false,
  ...mdxOptions
}) {
  const remarkPlugins = pluginOption(
    (v) => [
      plugins.remarkGfm,
      [
        plugins.remarkHeading,
        {
          generateToc: false,
          ...remarkHeadingOptions
        }
      ],
      remarkImageOptions !== false && [
        plugins.remarkImage,
        {
          ...remarkImageOptions,
          useImport: _withoutBundler ? false : remarkImageOptions?.useImport
        }
      ],
      "remarkCodeTab" in plugins && remarkCodeTabOptions !== false && [
        plugins.remarkCodeTab,
        remarkCodeTabOptions
      ],
      "remarkNpm" in plugins && remarkNpmOptions !== false && [plugins.remarkNpm, remarkNpmOptions],
      ...v,
      remarkStructureOptions !== false && [
        plugins.remarkStructure,
        remarkStructureOptions
      ],
      () => {
        return (_, file) => {
          file.data["mdx-export"] ??= [];
          for (const name of valueToExport) {
            if (name in file.data)
              file.data["mdx-export"].push({ name, value: file.data[name] });
          }
        };
      }
    ],
    mdxOptions.remarkPlugins
  );
  const rehypePlugins = pluginOption(
    (v) => [
      rehypeCodeOptions !== false && [plugins.rehypeCode, rehypeCodeOptions],
      ...v,
      plugins.rehypeToc
    ],
    mdxOptions.rehypePlugins
  );
  return {
    ...mdxOptions,
    outputFormat: _withoutBundler ? "function-body" : mdxOptions.outputFormat,
    remarkPlugins,
    rehypePlugins
  };
}

// src/loaders/mdx/remark-include.ts
var import_unified = require("unified");
var import_unist_util_visit2 = require("unist-util-visit");
var path = __toESM(require("path"), 1);
var fs = __toESM(require("fs/promises"), 1);

// src/utils/fuma-matter.ts
var import_js_yaml = require("js-yaml");
var regex = /^---\r?\n(.+?)\r?\n---\r?\n/s;
function fumaMatter(input) {
  const output = { matter: "", data: {}, content: input };
  const match = regex.exec(input);
  if (!match) {
    return output;
  }
  output.matter = match[0];
  output.content = input.slice(match[0].length);
  const loaded = (0, import_js_yaml.load)(match[1]);
  output.data = loaded ?? {};
  return output;
}

// src/loaders/mdx/remark-include.ts
var import_mdx_plugins = require("fumadocs-core/mdx-plugins");

// src/loaders/mdx/remark-unravel.ts
var import_unist_util_visit = require("unist-util-visit");
function remarkMarkAndUnravel() {
  return (tree) => {
    (0, import_unist_util_visit.visit)(tree, function(node, index, parent) {
      let offset = -1;
      let all = true;
      let oneOrMore = false;
      if (parent && typeof index === "number" && node.type === "paragraph") {
        const children = node.children;
        while (++offset < children.length) {
          const child = children[offset];
          if (child.type === "mdxJsxTextElement" || child.type === "mdxTextExpression") {
            oneOrMore = true;
          } else if (child.type === "text" && child.value.trim().length === 0) {
          } else {
            all = false;
            break;
          }
        }
        if (all && oneOrMore) {
          offset = -1;
          const newChildren = [];
          while (++offset < children.length) {
            const child = children[offset];
            if (child.type === "mdxJsxTextElement") {
              child.type = "mdxJsxFlowElement";
            }
            if (child.type === "mdxTextExpression") {
              child.type = "mdxFlowExpression";
            }
            if (child.type === "text" && /^[\t\r\n ]+$/.test(String(child.value))) {
            } else {
              newChildren.push(child);
            }
          }
          parent.children.splice(index, 1, ...newChildren);
          return index;
        }
      }
    });
  };
}

// src/loaders/mdx/remark-include.ts
var ElementLikeTypes = [
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "containerDirective",
  "textDirective",
  "leafDirective"
];
function isElementLike(node) {
  return ElementLikeTypes.includes(node.type);
}
function parseElementAttributes(element) {
  if (Array.isArray(element.attributes)) {
    const attributes = {};
    for (const attr of element.attributes) {
      if (attr.type === "mdxJsxAttribute" && (typeof attr.value === "string" || attr.value === null)) {
        attributes[attr.name] = attr.value;
      }
    }
    return attributes;
  }
  return element.attributes ?? {};
}
function flattenNode(node) {
  if ("children" in node)
    return node.children.map((child) => flattenNode(child)).join("");
  if ("value" in node) return node.value;
  return "";
}
function parseSpecifier(specifier) {
  const idx = specifier.lastIndexOf("#");
  if (idx === -1) return { file: specifier };
  return {
    file: specifier.slice(0, idx),
    section: specifier.slice(idx + 1)
  };
}
function extractSection(root, section) {
  let nodes;
  let capturingHeadingContent = false;
  (0, import_unist_util_visit2.visit)(root, (node) => {
    if (node.type === "heading") {
      if (capturingHeadingContent) {
        return false;
      }
      if (node.data?.hProperties?.id === section) {
        capturingHeadingContent = true;
        nodes = [node];
        return "skip";
      }
      return;
    }
    if (capturingHeadingContent) {
      nodes?.push(node);
      return "skip";
    }
    if (isElementLike(node) && node.name === "section") {
      const attributes = parseElementAttributes(node);
      if (attributes.id === section) {
        nodes = node.children;
        return false;
      }
    }
  });
  if (nodes)
    return {
      type: "root",
      children: nodes
    };
}
function remarkInclude() {
  const TagName = "include";
  const embedContent = async (file, heading, params, data) => {
    let content;
    try {
      content = (await fs.readFile(file)).toString();
    } catch (e) {
      throw new Error(
        `failed to read file ${file}
${e instanceof Error ? e.message : String(e)}`,
        { cause: e }
      );
    }
    const ext = path.extname(file);
    data._compiler?.addDependency(file);
    if (params.lang || ext !== ".md" && ext !== ".mdx") {
      const lang = params.lang ?? ext.slice(1);
      return {
        type: "code",
        lang,
        meta: params.meta,
        value: content,
        data: {}
      };
    }
    const parser = data._getProcessor ? data._getProcessor(ext === ".mdx" ? "mdx" : "md") : this;
    const parsed = fumaMatter(content);
    let mdast = parser.parse({
      path: file,
      value: parsed.content,
      data: { frontmatter: parsed.data }
    });
    const baseProcessor = (0, import_unified.unified)().use(remarkMarkAndUnravel);
    if (heading) {
      const extracted = extractSection(
        await baseProcessor.use(import_mdx_plugins.remarkHeading).run(mdast),
        heading
      );
      if (!extracted)
        throw new Error(
          `Cannot find section ${heading} in ${file}, make sure you have encapsulated the section in a <section id="${heading}"> tag, or a :::section directive with remark-directive configured.`
        );
      mdast = extracted;
    } else {
      mdast = await baseProcessor.run(mdast);
    }
    await update(mdast, path.dirname(file), data);
    return mdast;
  };
  async function update(tree, directory, data) {
    const queue = [];
    (0, import_unist_util_visit2.visit)(tree, ElementLikeTypes, (_node, _, parent) => {
      const node = _node;
      if (node.name !== TagName) return;
      const specifier = flattenNode(node);
      if (specifier.length === 0) return "skip";
      const attributes = parseElementAttributes(node);
      const { file: relativePath, section } = parseSpecifier(specifier);
      const file = path.resolve(
        "cwd" in attributes ? process.cwd() : directory,
        relativePath
      );
      queue.push(
        embedContent(file, section, attributes, data).then((replace) => {
          Object.assign(
            parent && parent.type === "paragraph" ? parent : node,
            replace
          );
        })
      );
      return "skip";
    });
    await Promise.all(queue);
  }
  return async (tree, file) => {
    await update(tree, path.dirname(file.path), file.data);
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  defineCollections,
  defineConfig,
  defineDocs,
  frontmatterSchema,
  getDefaultMDXOptions,
  metaSchema,
  remarkInclude
});
