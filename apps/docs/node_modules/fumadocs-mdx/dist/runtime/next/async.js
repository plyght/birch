import {
  _runtime,
  createMDXSource
} from "../../chunk-KILFIBVW.js";
import {
  createDocMethods
} from "../../chunk-NVRDCY6Z.js";
import {
  buildConfig
} from "../../chunk-2HXTGJBI.js";
import {
  buildMDX
} from "../../chunk-3J3WL7WN.js";
import "../../chunk-K5ZLPEIQ.js";
import {
  fumaMatter
} from "../../chunk-VWJKRQZR.js";

// src/runtime/next/async.ts
import { executeMdx } from "@fumadocs/mdx-remote/client";
import { pathToFileURL } from "url";
import fs from "fs/promises";
function getDocCollection(config, collection) {
  const col = config.getCollection(collection);
  if (col?.type === "doc" && col.mdxOptions) return col;
  if (col?.type === "docs" && col.docs.mdxOptions) return col.docs;
}
var _runtimeAsync = {
  doc(files, collectionName, config) {
    const collection = getDocCollection(config, collectionName);
    const initMdxOptions = collection?.mdxOptions ?? config.getDefaultMDXOptions("remote");
    return files.map(({ info, data, lastModified }) => {
      let cachedResult;
      async function compileAndLoad() {
        if (cachedResult) return cachedResult;
        const mdxOptions = await initMdxOptions;
        const raw = (await fs.readFile(info.fullPath)).toString();
        const { content } = fumaMatter(raw);
        const compiled = await buildMDX(collectionName, content, {
          ...mdxOptions,
          development: false,
          frontmatter: data,
          postprocess: collection?.postprocess,
          data: {
            lastModified
          },
          filePath: info.fullPath
        });
        const result = await executeMdx(String(compiled.value), {
          baseUrl: pathToFileURL(info.fullPath)
        });
        return cachedResult = result;
      }
      return {
        ...data,
        ...createDocMethods(info, () => compileAndLoad()),
        async load() {
          const out = await compileAndLoad();
          return {
            _exports: out,
            body: out.default,
            lastModified,
            toc: out.toc,
            extractedReferences: out.extractedReferences,
            structuredData: out.structuredData
          };
        }
      };
    });
  },
  docs(docs, metas, collection, config) {
    const parsedDocs = this.doc(docs, collection, config);
    const parsedMetas = _runtime.meta(metas);
    return {
      docs: parsedDocs,
      meta: parsedMetas,
      toFumadocsSource() {
        return createMDXSource(parsedDocs, parsedMetas);
      }
    };
  }
};
export {
  _runtimeAsync,
  buildConfig
};
