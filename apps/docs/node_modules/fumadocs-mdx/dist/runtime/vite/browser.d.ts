import { a as DocCollection, b as DocsCollection, M as MetaCollection } from '../../core-HkAVGq_a.js';
import { StandardSchemaV1 } from '@standard-schema/spec';
import { C as CompiledMDXProperties } from '../../build-mdx-DNzfRRlY.js';
import { ReactNode, FC } from 'react';
import '@mdx-js/mdx';
import 'fumadocs-core/mdx-plugins';
import 'unified';
import 'zod';
import 'chokidar';
import 'fumadocs-core/toc';
import 'mdx/types';

type CompiledMDXFile<Frontmatter> = CompiledMDXProperties<Frontmatter> & Record<string, unknown>;
type DocMap<Frontmatter> = Record<string, (() => Promise<CompiledMDXFile<Frontmatter>>) & {
    base: string;
}>;
type MetaMap<Data> = Record<string, (() => Promise<Data>) & {
    base: string;
}>;
interface LazyDocMap<Frontmatter> {
    base: string;
    head: Record<string, () => Promise<Frontmatter>>;
    body: Record<string, () => Promise<CompiledMDXFile<Frontmatter>>>;
}
interface BaseCreate<Config> {
    doc: <Name extends keyof Config>(name: Name, base: string, glob: Record<string, () => Promise<unknown>>) => Config[Name] extends DocCollection<infer Schema> | DocsCollection<infer Schema> ? DocMap<StandardSchemaV1.InferOutput<Schema>> : never;
    docLazy: <Name extends keyof Config>(name: Name, base: string, headGlob: Record<string, () => Promise<unknown>>, bodyGlob: Record<string, () => Promise<unknown>>) => Config[Name] extends DocCollection<infer Schema> | DocsCollection<infer Schema> ? LazyDocMap<StandardSchemaV1.InferOutput<Schema>> : never;
    meta: <Name extends keyof Config>(name: Name, base: string, glob: Record<string, () => Promise<unknown>>) => Config[Name] extends MetaCollection<infer Schema> | DocsCollection<StandardSchemaV1, infer Schema> ? MetaMap<StandardSchemaV1.InferOutput<Schema>> : never;
}
declare function fromConfigBase<Config>(): BaseCreate<Config>;
interface ClientLoaderOptions<Frontmatter, Props> {
    /**
     * Loader ID (usually your collection name)
     *
     * The code splitting strategy of frameworks like Tanstack Start may duplicate `createClientLoader()` into different chunks.
     *
     * We use loader ID to share cache between multiple instances of client loader.
     *
     * @defaultValue ''
     */
    id?: string;
    component: (loaded: CompiledMDXFile<Frontmatter>, props: Props) => ReactNode;
}
interface ClientLoader<Frontmatter, Props> {
    preload: (path: string) => Promise<CompiledMDXFile<Frontmatter>>;
    /**
     * Get a component that renders content with `React.lazy`.
     */
    getComponent: (path: string) => FC<Props>;
    /**
     * Get react nodes that renders content with `React.lazy`.
     */
    useContent: (path: string, props: Props) => ReactNode;
    getRenderer: () => Record<string, FC<Props>>;
}
declare function createClientLoader<Frontmatter, Props extends object = object>(files: Record<string, () => Promise<CompiledMDXFile<Frontmatter>>>, options: ClientLoaderOptions<Frontmatter, Props>): ClientLoader<Frontmatter, Props>;
declare function toClientRenderer<Frontmatter, Props extends object = object>(files: Record<string, () => Promise<CompiledMDXFile<Frontmatter>>>, component: (loaded: CompiledMDXFile<Frontmatter>, props: Props) => ReactNode): Record<string, FC<Props>>;

export { type BaseCreate, type ClientLoader, type ClientLoaderOptions, type CompiledMDXFile, type DocMap, type LazyDocMap, type MetaMap, createClientLoader, fromConfigBase as fromConfig, fromConfigBase, toClientRenderer };
