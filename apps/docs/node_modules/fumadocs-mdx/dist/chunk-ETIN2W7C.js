import {
  ValidationError
} from "./chunk-2AQRQXSO.js";

// src/loaders/adapter.ts
import { fileURLToPath } from "url";
import fs from "fs/promises";
import { parse } from "querystring";
import path from "path";
function toNode(loader) {
  return async (url, _context, nextLoad) => {
    if (url.startsWith("file:///") && (!loader.test || loader.test.test(url))) {
      const parsedUrl = new URL(url);
      const filePath = fileURLToPath(parsedUrl);
      const result = await loader.load({
        filePath,
        query: Object.fromEntries(parsedUrl.searchParams.entries()),
        async getSource() {
          return (await fs.readFile(filePath)).toString();
        },
        development: false,
        compiler: {
          addDependency() {
          }
        }
      });
      if (result) {
        return {
          source: result.code,
          format: "module",
          shortCircuit: true
        };
      }
    }
    return nextLoad(url);
  };
}
function toVite(loader) {
  return {
    filter(id) {
      return !loader.test || loader.test.test(id);
    },
    async transform(value, id) {
      const [file, query = ""] = id.split("?", 2);
      const result = await loader.load({
        filePath: file,
        query: parse(query),
        getSource() {
          return value;
        },
        development: this.environment.mode === "dev",
        compiler: {
          addDependency: (file2) => {
            this.addWatchFile(file2);
          }
        }
      });
      if (result === null) return null;
      return {
        code: result.code,
        map: result.map
      };
    }
  };
}
function toWebpack(loader) {
  return async function(source, callback) {
    try {
      const result = await loader.load({
        filePath: this.resourcePath,
        query: parse(this.resourceQuery.slice(1)),
        getSource() {
          return source;
        },
        development: this.mode === "development",
        compiler: this
      });
      if (result === null) {
        callback(void 0, source);
      } else {
        callback(void 0, result.code, result.map);
      }
    } catch (error) {
      if (error instanceof ValidationError) {
        return callback(new Error(error.toStringFormatted()));
      }
      if (!(error instanceof Error)) throw error;
      const fpath = path.relative(this.context, this.resourcePath);
      error.message = `${fpath}:${error.name}: ${error.message}`;
      callback(error);
    }
  };
}
function toBun(loader) {
  return (build) => {
    build.onLoad({ filter: loader.test ?? /.+/ }, async (args) => {
      const [filePath, query = ""] = args.path.split("?", 2);
      const input = {
        async getSource() {
          return Bun.file(filePath).text();
        },
        query: parse(query),
        filePath,
        development: false,
        compiler: {
          addDependency() {
          }
        }
      };
      const result = await loader.load(input);
      if (result === null) {
        if (!loader.bun?.fallback) {
          return;
        }
        return loader.bun.fallback(input);
      }
      return {
        contents: result.code,
        loader: "js"
      };
    });
  };
}

// src/loaders/config.ts
import fs2 from "fs/promises";
function createStandaloneConfigLoader({
  core,
  buildConfig,
  mode
}) {
  let loaded;
  async function getConfigHash() {
    if (mode === "production") return "static";
    const stats = await fs2.stat(core._options.configPath).catch(() => {
      throw new Error("Cannot find config file");
    });
    return stats.mtime.getTime().toString();
  }
  async function newConfig() {
    const { loadConfig } = await import("./load-from-file-AVYOFOI7.js");
    await core.init({
      config: loadConfig(
        core._options.configPath,
        core._options.outDir,
        buildConfig
      )
    });
    return core.getConfig();
  }
  return {
    async getConfig() {
      const hash = await getConfigHash();
      if (loaded && loaded.hash === hash) return loaded.config;
      loaded = {
        hash,
        config: newConfig()
      };
      return loaded.config;
    }
  };
}
function createIntegratedConfigLoader(core) {
  return {
    getConfig() {
      return core.getConfig();
    }
  };
}

export {
  toNode,
  toVite,
  toWebpack,
  toBun,
  createStandaloneConfigLoader,
  createIntegratedConfigLoader
};
