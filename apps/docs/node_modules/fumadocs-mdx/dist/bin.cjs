#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/loaders/mdx/preset.ts
var preset_exports = {};
__export(preset_exports, {
  getDefaultMDXOptions: () => getDefaultMDXOptions
});
function pluginOption(def, options = []) {
  const list = def(Array.isArray(options) ? options : []).filter(
    Boolean
  );
  if (typeof options === "function") {
    return options(list);
  }
  return list;
}
function getDefaultMDXOptions({
  valueToExport = [],
  rehypeCodeOptions,
  remarkImageOptions,
  remarkHeadingOptions,
  remarkStructureOptions,
  remarkCodeTabOptions,
  remarkNpmOptions,
  _withoutBundler = false,
  ...mdxOptions
}) {
  const remarkPlugins = pluginOption(
    (v) => [
      plugins.remarkGfm,
      [
        plugins.remarkHeading,
        {
          generateToc: false,
          ...remarkHeadingOptions
        }
      ],
      remarkImageOptions !== false && [
        plugins.remarkImage,
        {
          ...remarkImageOptions,
          useImport: _withoutBundler ? false : remarkImageOptions?.useImport
        }
      ],
      "remarkCodeTab" in plugins && remarkCodeTabOptions !== false && [
        plugins.remarkCodeTab,
        remarkCodeTabOptions
      ],
      "remarkNpm" in plugins && remarkNpmOptions !== false && [plugins.remarkNpm, remarkNpmOptions],
      ...v,
      remarkStructureOptions !== false && [
        plugins.remarkStructure,
        remarkStructureOptions
      ],
      () => {
        return (_, file) => {
          file.data["mdx-export"] ??= [];
          for (const name of valueToExport) {
            if (name in file.data)
              file.data["mdx-export"].push({ name, value: file.data[name] });
          }
        };
      }
    ],
    mdxOptions.remarkPlugins
  );
  const rehypePlugins = pluginOption(
    (v) => [
      rehypeCodeOptions !== false && [plugins.rehypeCode, rehypeCodeOptions],
      ...v,
      plugins.rehypeToc
    ],
    mdxOptions.rehypePlugins
  );
  return {
    ...mdxOptions,
    outputFormat: _withoutBundler ? "function-body" : mdxOptions.outputFormat,
    remarkPlugins,
    rehypePlugins
  };
}
var plugins;
var init_preset = __esm({
  "src/loaders/mdx/preset.ts"() {
    "use strict";
    plugins = __toESM(require("fumadocs-core/mdx-plugins"), 1);
  }
});

// src/config/build.ts
function buildCollection(name, config) {
  if (config.type === "docs") {
    return {
      ...config,
      name,
      meta: buildPrimitiveCollection(name, config.meta),
      docs: buildPrimitiveCollection(name, config.docs)
    };
  }
  return buildPrimitiveCollection(name, config);
}
function buildPrimitiveCollection(name, { files, ...config }) {
  const supportedFormats = SupportedFormats[config.type];
  const patterns = files ?? [`**/*.{${supportedFormats.join(",")}}`];
  let matchers;
  return {
    ...config,
    name,
    patterns,
    isFileSupported(filePath) {
      return supportedFormats.some((format) => filePath.endsWith(`.${format}`));
    },
    hasFile(filePath) {
      matchers ??= (Array.isArray(config.dir) ? config.dir : [config.dir]).map(
        (dir) => (0, import_picomatch.default)(patterns, {
          cwd: dir
        })
      );
      return this.isFileSupported(filePath) && matchers.some((matcher) => matcher(filePath));
    }
  };
}
function buildConfig(config) {
  const collections = /* @__PURE__ */ new Map();
  const loaded = {};
  for (const [k, v] of Object.entries(config)) {
    if (!v) {
      continue;
    }
    if (typeof v === "object" && "type" in v) {
      if (v.type === "docs") {
        collections.set(k, buildCollection(k, v));
        continue;
      }
      if (v.type === "doc" || v.type === "meta") {
        collections.set(
          k,
          buildCollection(k, v)
        );
        continue;
      }
    }
    if (k === "default" && v) {
      Object.assign(loaded, v);
      continue;
    }
    throw new Error(
      `Unknown export "${k}", you can only export collections from source configuration file.`
    );
  }
  if (loaded.collections) {
    for (const [k, v] of Object.entries(loaded.collections)) {
      collections.set(k, buildCollection(k, v));
    }
  }
  const mdxOptionsCache = /* @__PURE__ */ new Map();
  return {
    global: loaded,
    collectionList: Array.from(collections.values()),
    getCollection(name) {
      return collections.get(name);
    },
    async getDefaultMDXOptions(mode = "default") {
      const cached = mdxOptionsCache.get(mode);
      if (cached) return cached;
      const input = this.global.mdxOptions;
      async function uncached() {
        const options = typeof input === "function" ? await input() : input;
        const { getDefaultMDXOptions: getDefaultMDXOptions2 } = await Promise.resolve().then(() => (init_preset(), preset_exports));
        if (options?.preset === "minimal") return options;
        return getDefaultMDXOptions2({
          ...options,
          _withoutBundler: mode === "remote"
        });
      }
      const result = uncached();
      mdxOptionsCache.set(mode, result);
      return result;
    }
  };
}
var import_picomatch, SupportedFormats;
var init_build = __esm({
  "src/config/build.ts"() {
    "use strict";
    import_picomatch = __toESM(require("picomatch"), 1);
    SupportedFormats = {
      doc: ["mdx", "md"],
      meta: ["json", "yaml"]
    };
  }
});

// src/config/load-from-file.ts
var load_from_file_exports = {};
__export(load_from_file_exports, {
  loadConfig: () => loadConfig
});
async function compileConfig(configPath, outDir) {
  const { build } = await import("esbuild");
  const transformed = await build({
    entryPoints: [{ in: configPath, out: "source.config" }],
    bundle: true,
    outdir: outDir,
    target: "node20",
    write: true,
    platform: "node",
    format: "esm",
    packages: "external",
    outExtension: {
      ".js": ".mjs"
    },
    allowOverwrite: true
  });
  if (transformed.errors.length > 0) {
    throw new Error("failed to compile configuration file");
  }
}
async function loadConfig(configPath, outDir, build = false) {
  if (build) await compileConfig(configPath, outDir);
  const url = (0, import_node_url.pathToFileURL)(path.resolve(outDir, "source.config.mjs"));
  url.searchParams.set("hash", Date.now().toString());
  const config = import(url.href).then(
    (loaded) => buildConfig(loaded)
  );
  return await config;
}
var path, import_node_url;
var init_load_from_file = __esm({
  "src/config/load-from-file.ts"() {
    "use strict";
    path = __toESM(require("path"), 1);
    import_node_url = require("url");
    init_build();
  }
});

// src/next/file-cache.ts
function toFullPath(file) {
  if (import_node_path.default.isAbsolute(file)) {
    return import_node_path.default.relative(process.cwd(), file);
  }
  return file;
}
async function readFileWithCache(file) {
  const fullPath = toFullPath(file);
  const cached = map.get(fullPath);
  if (cached) return cached;
  const read = import_promises.default.readFile(fullPath).then((s) => s.toString());
  map.set(fullPath, read);
  return read;
}
function removeFileCache(file) {
  map.delete(toFullPath(file));
}
var import_lru_cache, import_promises, import_node_path, map;
var init_file_cache = __esm({
  "src/next/file-cache.ts"() {
    "use strict";
    import_lru_cache = require("lru-cache");
    import_promises = __toESM(require("fs/promises"), 1);
    import_node_path = __toESM(require("path"), 1);
    map = new import_lru_cache.LRUCache({
      max: 100
    });
  }
});

// src/utils/validation.ts
async function validate(schema, data, context, errorMessage) {
  if (typeof schema === "function" && !("~standard" in schema)) {
    schema = schema(context);
  }
  if ("~standard" in schema) {
    const result = await schema["~standard"].validate(
      data
    );
    if (result.issues) {
      throw new ValidationError(errorMessage, result.issues);
    }
    return result.value;
  }
  return data;
}
var import_picocolors, ValidationError;
var init_validation = __esm({
  "src/utils/validation.ts"() {
    "use strict";
    import_picocolors = __toESM(require("picocolors"), 1);
    ValidationError = class extends Error {
      constructor(message, issues) {
        super(
          `${message}:
${issues.map((issue) => `  ${issue.path}: ${issue.message}`).join("\n")}`
        );
        this.title = message;
        this.issues = issues;
      }
      toStringFormatted() {
        return [
          import_picocolors.default.bold(`[MDX] ${this.title}:`),
          ...this.issues.map(
            (issue) => import_picocolors.default.redBright(
              `- ${import_picocolors.default.bold(issue.path?.join(".") ?? "*")}: ${issue.message}`
            )
          )
        ].join("\n");
      }
    };
  }
});

// src/utils/git-timestamp.ts
async function getGitTimestamp(file) {
  const cached = cache.get(file);
  if (cached) return cached;
  try {
    const out = await (0, import_tinyexec.x)(
      "git",
      ["log", "-1", '--pretty="%ai"', import_node_path2.default.relative(process.cwd(), file)],
      {
        throwOnError: true
      }
    );
    const time = new Date(out.stdout);
    cache.set(file, time);
    return time;
  } catch {
    return;
  }
}
var import_node_path2, import_tinyexec, cache;
var init_git_timestamp = __esm({
  "src/utils/git-timestamp.ts"() {
    "use strict";
    import_node_path2 = __toESM(require("path"), 1);
    import_tinyexec = require("tinyexec");
    cache = /* @__PURE__ */ new Map();
  }
});

// src/utils/fuma-matter.ts
function fumaMatter(input) {
  const output = { matter: "", data: {}, content: input };
  const match = regex.exec(input);
  if (!match) {
    return output;
  }
  output.matter = match[0];
  output.content = input.slice(match[0].length);
  const loaded = (0, import_js_yaml.load)(match[1]);
  output.data = loaded ?? {};
  return output;
}
var import_js_yaml, regex;
var init_fuma_matter = __esm({
  "src/utils/fuma-matter.ts"() {
    "use strict";
    import_js_yaml = require("js-yaml");
    regex = /^---\r?\n(.+?)\r?\n---\r?\n/s;
  }
});

// src/utils/import-formatter.ts
function getImportCode(info) {
  const specifier = JSON.stringify(info.specifier);
  if (info.type === "default") return `import ${info.name} from ${specifier}`;
  if (info.type === "namespace")
    return `import * as ${info.name} from ${specifier}`;
  if (info.type === "named") {
    const names = info.names.map(
      (name) => Array.isArray(name) ? `${name[0]} as ${name[1]}` : name
    );
    return `import { ${names.join(", ")} } from ${specifier}`;
  }
  return `import ${specifier}`;
}
function toImportPath(file, config) {
  const ext = import_node_path3.default.extname(file);
  let filename;
  if (ext === ".ts" && config.jsExtension) {
    filename = file.substring(0, file.length - ext.length) + ".js";
  } else if (ext === ".ts") {
    filename = file.substring(0, file.length - ext.length);
  } else {
    filename = file;
  }
  let importPath;
  if ("relativeTo" in config) {
    importPath = import_node_path3.default.relative(config.relativeTo, filename);
    if (!import_node_path3.default.isAbsolute(importPath) && !importPath.startsWith(".")) {
      importPath = `./${importPath}`;
    }
  } else {
    importPath = import_node_path3.default.resolve(filename);
  }
  return importPath.replaceAll(import_node_path3.default.sep, "/");
}
function ident(code, tab = 1) {
  return code.split("\n").map((v) => "  ".repeat(tab) + v).join("\n");
}
var import_node_path3;
var init_import_formatter = __esm({
  "src/utils/import-formatter.ts"() {
    "use strict";
    import_node_path3 = __toESM(require("path"), 1);
  }
});

// src/plugins/next.ts
function next() {
  let config;
  let shouldEmitOnChange = false;
  return {
    name: "next",
    config(v) {
      config = v;
      shouldEmitOnChange = config.collectionList.some((collection) => {
        return collection.type === "doc" && collection.async || collection.type === "docs" || collection.type === "meta";
      });
    },
    configureServer(server) {
      if (!server.watcher) return;
      server.watcher.on("all", async (event) => {
        if (event === "change" && !shouldEmitOnChange) return;
        await this.core.emitAndWrite({
          filterPlugin: (plugin) => plugin.name === "next"
        });
      });
    },
    async emit() {
      return [
        {
          path: "index.ts",
          content: await indexFile(this.configPath, config, {
            relativeTo: this.outDir
          })
        }
      ];
    }
  };
}
async function indexFile(configPath, config, importPath) {
  let asyncInit = false;
  const lines = [
    getImportCode({
      type: "named",
      names: ["_runtime"],
      specifier: "fumadocs-mdx/runtime/next"
    }),
    getImportCode({
      type: "namespace",
      specifier: toImportPath(configPath, importPath),
      name: "_source"
    })
  ];
  function getDocEntries(collection, files) {
    return files.map((file, i) => {
      const importId = `d_${collection.name}_${i}`;
      const params = [`collection=${collection.name}`];
      lines.unshift(
        getImportCode({
          type: "namespace",
          name: importId,
          specifier: `${toImportPath(file.fullPath, importPath)}?${params.join("&")}`
        })
      );
      return `{ info: ${JSON.stringify(file)}, data: ${importId} }`;
    });
  }
  async function getMetaEntries(collection, files) {
    const items = files.map(async (file) => {
      const source = await readFileWithCache(file.fullPath).catch(() => "");
      let data = source.length === 0 ? {} : parseMetaEntry(file.fullPath, source);
      if (collection?.schema) {
        data = await validate(
          collection.schema,
          data,
          {
            source,
            path: file.fullPath
          },
          `invalid data in ${file.fullPath}`
        );
      }
      return JSON.stringify({
        info: file,
        data
      });
    });
    return Promise.all(items);
  }
  async function getAsyncEntries(collection, files) {
    if (!asyncInit) {
      lines.unshift(
        getImportCode({
          type: "named",
          specifier: "fumadocs-mdx/runtime/async",
          names: ["_runtimeAsync", "buildConfig"]
        }),
        "const _sourceConfig = buildConfig(_source)",
        getImportCode({
          type: "default",
          name: "path",
          specifier: "node:path"
        })
      );
      asyncInit = true;
    }
    const entries = files.map(async (file) => {
      const content = await readFileWithCache(file.fullPath).catch(() => "");
      const parsed = fumaMatter(content);
      let data = parsed.data;
      if (collection.schema) {
        data = await validate(
          collection.schema,
          parsed.data,
          { path: file.fullPath, source: parsed.content },
          `invalid frontmatter in ${file.fullPath}`
        );
      }
      let lastModified;
      if (config.global?.lastModifiedTime === "git") {
        lastModified = await getGitTimestamp(file.fullPath);
      }
      const hash = (0, import_node_crypto.createHash)("md5").update(content).digest("hex");
      const infoStr = [];
      for (const [k, v] of Object.entries({ ...file, hash })) {
        infoStr.push(`${k}: ${JSON.stringify(v)}`);
      }
      infoStr.push(
        `absolutePath: path.resolve(${JSON.stringify(file.fullPath)})`
      );
      return `{ info: { ${infoStr.join(", ")} }, lastModified: ${JSON.stringify(lastModified)}, data: ${JSON.stringify(data)} }`;
    });
    return Promise.all(entries);
  }
  const declares = config.collectionList.map(async (collection) => {
    const k = collection.name;
    if (collection.type === "docs") {
      const docs = await globCollectionFiles(collection.docs);
      const metas = await globCollectionFiles(collection.meta);
      const metaEntries = (await getMetaEntries(collection.meta, metas)).join(
        ", "
      );
      if (collection.docs.async) {
        const docsEntries2 = (await getAsyncEntries(collection.docs, docs)).join(
          ", "
        );
        return `export const ${k} = _runtimeAsync.docs<typeof _source.${k}>([${docsEntries2}], [${metaEntries}], "${k}", _sourceConfig)`;
      }
      const docsEntries = getDocEntries(collection.docs, docs).join(", ");
      return `export const ${k} = _runtime.docs<typeof _source.${k}>([${docsEntries}], [${metaEntries}])`;
    }
    const files = await globCollectionFiles(collection);
    if (collection.type === "meta") {
      return `export const ${k} = _runtime.meta<typeof _source.${k}>([${(await getMetaEntries(collection, files)).join(", ")}]);`;
    }
    if (collection.async) {
      return `export const ${k} = _runtimeAsync.doc<typeof _source.${k}>([${(await getAsyncEntries(collection, files)).join(", ")}], "${k}", _sourceConfig)`;
    }
    return `export const ${k} = _runtime.doc<typeof _source.${k}>([${getDocEntries(collection, files).join(", ")}]);`;
  });
  const resolvedDeclares = await Promise.all(declares);
  return [
    `// @ts-nocheck -- skip type checking`,
    ...lines,
    ...resolvedDeclares
  ].join("\n");
}
function parseMetaEntry(file, content) {
  const extname3 = path5.extname(file);
  try {
    if (extname3 === ".json") return JSON.parse(content);
    if (extname3 === ".yaml") return (0, import_js_yaml2.load)(content);
  } catch (e) {
    throw new Error(`Failed to parse meta file: ${file}.`, {
      cause: e
    });
  }
  throw new Error(`Unknown meta file format: ${extname3}, in ${file}.`);
}
async function globCollectionFiles(collection) {
  const { glob } = await import("tinyglobby");
  const files = /* @__PURE__ */ new Map();
  const dirs = Array.isArray(collection.dir) ? collection.dir : [collection.dir];
  await Promise.all(
    dirs.map(async (dir) => {
      const result = await glob(collection.patterns, {
        cwd: path5.resolve(dir)
      });
      for (const item of result) {
        if (!collection.isFileSupported(item)) continue;
        const fullPath = path5.join(dir, item);
        files.set(fullPath, {
          path: item,
          fullPath
        });
      }
    })
  );
  return Array.from(files.values());
}
var path5, import_node_crypto, import_js_yaml2;
var init_next = __esm({
  "src/plugins/next.ts"() {
    "use strict";
    path5 = __toESM(require("path"), 1);
    import_node_crypto = require("crypto");
    init_validation();
    init_file_cache();
    init_git_timestamp();
    init_fuma_matter();
    init_import_formatter();
    import_js_yaml2 = require("js-yaml");
  }
});

// src/core.ts
function findConfigFile() {
  return import_node_path4.default.resolve("source.config.ts");
}
function createCore(options, defaultPlugins = []) {
  let config;
  let plugins2;
  return {
    _options: options,
    getPluginContext() {
      return {
        core: this,
        ...options
      };
    },
    /**
     * Convenient cache store, reset when config changes
     */
    cache: /* @__PURE__ */ new Map(),
    async init({ config: newConfig }) {
      config = await newConfig;
      this.cache.clear();
      plugins2 = [];
      for await (const option of [
        ...defaultPlugins,
        ...config.global.plugins ?? []
      ]) {
        if (!option) continue;
        if (Array.isArray(option)) plugins2.push(...option);
        else plugins2.push(option);
      }
      for (const plugin of plugins2) {
        const out = await plugin.config?.call(this.getPluginContext(), config);
        if (out) config = out;
      }
      return this;
    },
    getConfig() {
      return config;
    },
    async initServer(server) {
      for (const plugin of plugins2) {
        await plugin.configureServer?.call(this.getPluginContext(), server);
      }
    },
    async emitAndWrite({
      filterPlugin = () => true
    } = {}) {
      const start2 = performance.now();
      const out = await Promise.all(
        plugins2.map((plugin) => {
          if (!filterPlugin(plugin) || !plugin.emit) return [];
          return plugin.emit.call(this.getPluginContext());
        })
      );
      await Promise.all(
        out.flat().map(async (entry) => {
          const file = import_node_path4.default.join(options.outDir, entry.path);
          await import_promises2.default.mkdir(import_node_path4.default.dirname(file), { recursive: true });
          await import_promises2.default.writeFile(file, entry.content);
        })
      );
      console.log(`[MDX] generated files in ${performance.now() - start2}ms`);
    }
  };
}
var import_node_path4, import_promises2;
var init_core = __esm({
  "src/core.ts"() {
    "use strict";
    import_node_path4 = __toESM(require("path"), 1);
    import_promises2 = __toESM(require("fs/promises"), 1);
  }
});

// src/loaders/index.ts
var metaLoaderGlob, mdxLoaderGlob;
var init_loaders = __esm({
  "src/loaders/index.ts"() {
    "use strict";
    metaLoaderGlob = /\.(json|yaml)(\?.+?)?$/;
    mdxLoaderGlob = /\.mdx?(\?.+?)?$/;
  }
});

// src/next/index.ts
var next_exports = {};
__export(next_exports, {
  createMDX: () => createMDX,
  postInstall: () => postInstall
});
function createMDX(createOptions = {}) {
  const options = applyDefaults(createOptions);
  const isDev = process.env.NODE_ENV === "development";
  if (process.env._FUMADOCS_MDX !== "1") {
    process.env._FUMADOCS_MDX = "1";
    void init(isDev, options);
  }
  return (nextConfig = {}) => {
    const loaderOptions = {
      ...options,
      isDev
    };
    const turbopack = {
      ...nextConfig.turbopack,
      rules: {
        ...nextConfig.turbopack?.rules,
        "*.{md,mdx}": {
          loaders: [
            {
              loader: "fumadocs-mdx/loader-mdx",
              options: loaderOptions
            }
          ],
          as: "*.js"
        }
      }
    };
    return {
      ...nextConfig,
      turbopack,
      pageExtensions: nextConfig.pageExtensions ?? defaultPageExtensions,
      webpack: (config, options2) => {
        config.resolve ||= {};
        config.module ||= {};
        config.module.rules ||= [];
        config.module.rules.push({
          test: mdxLoaderGlob,
          use: [
            options2.defaultLoaders.babel,
            {
              loader: "fumadocs-mdx/loader-mdx",
              options: loaderOptions
            }
          ]
        });
        config.plugins ||= [];
        return nextConfig.webpack?.(config, options2) ?? config;
      }
    };
  };
}
async function init(dev, options) {
  const core = createNextCore(options);
  async function initOrReload() {
    await core.init({
      config: loadConfig(options.configPath, options.outDir, true)
    });
    await core.emitAndWrite();
  }
  async function devServer() {
    const { FSWatcher } = await import("chokidar");
    const watcher = new FSWatcher({
      ignoreInitial: true,
      persistent: true,
      ignored: [options.outDir]
    });
    watcher.add(options.configPath);
    for (const collection of core.getConfig().collectionList) {
      if (collection.type === "docs") {
        watcher.add(collection.docs.dir);
        watcher.add(collection.meta.dir);
      } else {
        watcher.add(collection.dir);
      }
    }
    watcher.on("ready", () => {
      console.log("[MDX] started dev server");
    });
    watcher.on("all", async (event, file) => {
      const absolutePath = path7.resolve(file);
      if (event === "change") removeFileCache(absolutePath);
      if (absolutePath === path7.resolve(options.configPath)) {
        watcher.removeAllListeners();
        await watcher.close();
        await initOrReload();
        console.log("[MDX] restarting dev server");
        await devServer();
      }
    });
    process.on("exit", () => {
      if (watcher.closed) return;
      console.log("[MDX] closing dev server");
      void watcher.close();
    });
    await core.initServer({ watcher });
  }
  await initOrReload();
  if (dev) {
    await devServer();
  }
}
async function postInstall(configPath = findConfigFile(), outDir = ".source") {
  const core = await createNextCore({
    outDir,
    configPath
  }).init({
    config: loadConfig(configPath, outDir, true)
  });
  await core.emitAndWrite();
}
function applyDefaults(options) {
  return {
    outDir: options.outDir ?? ".source",
    configPath: options.configPath ?? findConfigFile()
  };
}
function createNextCore({
  outDir,
  configPath
}) {
  const core = createCore(
    {
      environment: "next",
      outDir,
      configPath
    },
    [next()]
  );
  return {
    ...core,
    async emitAndWrite(...args) {
      try {
        await core.emitAndWrite(...args);
      } catch (err) {
        if (err instanceof ValidationError) {
          console.error(err.toStringFormatted());
        } else {
          console.error(err);
        }
      }
    }
  };
}
var path7, defaultPageExtensions;
var init_next2 = __esm({
  "src/next/index.ts"() {
    "use strict";
    path7 = __toESM(require("path"), 1);
    init_load_from_file();
    init_file_cache();
    init_validation();
    init_next();
    init_core();
    init_loaders();
    defaultPageExtensions = ["mdx", "md", "jsx", "js", "tsx", "ts"];
  }
});

// src/loaders/mdx/remark-unravel.ts
function remarkMarkAndUnravel() {
  return (tree) => {
    (0, import_unist_util_visit.visit)(tree, function(node, index, parent) {
      let offset = -1;
      let all = true;
      let oneOrMore = false;
      if (parent && typeof index === "number" && node.type === "paragraph") {
        const children = node.children;
        while (++offset < children.length) {
          const child = children[offset];
          if (child.type === "mdxJsxTextElement" || child.type === "mdxTextExpression") {
            oneOrMore = true;
          } else if (child.type === "text" && child.value.trim().length === 0) {
          } else {
            all = false;
            break;
          }
        }
        if (all && oneOrMore) {
          offset = -1;
          const newChildren = [];
          while (++offset < children.length) {
            const child = children[offset];
            if (child.type === "mdxJsxTextElement") {
              child.type = "mdxJsxFlowElement";
            }
            if (child.type === "mdxTextExpression") {
              child.type = "mdxFlowExpression";
            }
            if (child.type === "text" && /^[\t\r\n ]+$/.test(String(child.value))) {
            } else {
              newChildren.push(child);
            }
          }
          parent.children.splice(index, 1, ...newChildren);
          return index;
        }
      }
    });
  };
}
var import_unist_util_visit;
var init_remark_unravel = __esm({
  "src/loaders/mdx/remark-unravel.ts"() {
    "use strict";
    import_unist_util_visit = require("unist-util-visit");
  }
});

// src/loaders/mdx/remark-include.ts
function isElementLike(node) {
  return ElementLikeTypes.includes(node.type);
}
function parseElementAttributes(element) {
  if (Array.isArray(element.attributes)) {
    const attributes = {};
    for (const attr of element.attributes) {
      if (attr.type === "mdxJsxAttribute" && (typeof attr.value === "string" || attr.value === null)) {
        attributes[attr.name] = attr.value;
      }
    }
    return attributes;
  }
  return element.attributes ?? {};
}
function flattenNode(node) {
  if ("children" in node)
    return node.children.map((child) => flattenNode(child)).join("");
  if ("value" in node) return node.value;
  return "";
}
function parseSpecifier(specifier) {
  const idx = specifier.lastIndexOf("#");
  if (idx === -1) return { file: specifier };
  return {
    file: specifier.slice(0, idx),
    section: specifier.slice(idx + 1)
  };
}
function extractSection(root, section) {
  let nodes;
  let capturingHeadingContent = false;
  (0, import_unist_util_visit2.visit)(root, (node) => {
    if (node.type === "heading") {
      if (capturingHeadingContent) {
        return false;
      }
      if (node.data?.hProperties?.id === section) {
        capturingHeadingContent = true;
        nodes = [node];
        return "skip";
      }
      return;
    }
    if (capturingHeadingContent) {
      nodes?.push(node);
      return "skip";
    }
    if (isElementLike(node) && node.name === "section") {
      const attributes = parseElementAttributes(node);
      if (attributes.id === section) {
        nodes = node.children;
        return false;
      }
    }
  });
  if (nodes)
    return {
      type: "root",
      children: nodes
    };
}
function remarkInclude() {
  const TagName = "include";
  const embedContent = async (file, heading, params, data) => {
    let content;
    try {
      content = (await fs3.readFile(file)).toString();
    } catch (e) {
      throw new Error(
        `failed to read file ${file}
${e instanceof Error ? e.message : String(e)}`,
        { cause: e }
      );
    }
    const ext = path8.extname(file);
    data._compiler?.addDependency(file);
    if (params.lang || ext !== ".md" && ext !== ".mdx") {
      const lang = params.lang ?? ext.slice(1);
      return {
        type: "code",
        lang,
        meta: params.meta,
        value: content,
        data: {}
      };
    }
    const parser = data._getProcessor ? data._getProcessor(ext === ".mdx" ? "mdx" : "md") : this;
    const parsed = fumaMatter(content);
    let mdast = parser.parse({
      path: file,
      value: parsed.content,
      data: { frontmatter: parsed.data }
    });
    const baseProcessor = (0, import_unified.unified)().use(remarkMarkAndUnravel);
    if (heading) {
      const extracted = extractSection(
        await baseProcessor.use(import_mdx_plugins.remarkHeading).run(mdast),
        heading
      );
      if (!extracted)
        throw new Error(
          `Cannot find section ${heading} in ${file}, make sure you have encapsulated the section in a <section id="${heading}"> tag, or a :::section directive with remark-directive configured.`
        );
      mdast = extracted;
    } else {
      mdast = await baseProcessor.run(mdast);
    }
    await update(mdast, path8.dirname(file), data);
    return mdast;
  };
  async function update(tree, directory, data) {
    const queue = [];
    (0, import_unist_util_visit2.visit)(tree, ElementLikeTypes, (_node, _, parent) => {
      const node = _node;
      if (node.name !== TagName) return;
      const specifier = flattenNode(node);
      if (specifier.length === 0) return "skip";
      const attributes = parseElementAttributes(node);
      const { file: relativePath, section } = parseSpecifier(specifier);
      const file = path8.resolve(
        "cwd" in attributes ? process.cwd() : directory,
        relativePath
      );
      queue.push(
        embedContent(file, section, attributes, data).then((replace) => {
          Object.assign(
            parent && parent.type === "paragraph" ? parent : node,
            replace
          );
        })
      );
      return "skip";
    });
    await Promise.all(queue);
  }
  return async (tree, file) => {
    await update(tree, path8.dirname(file.path), file.data);
  };
}
var import_unified, import_unist_util_visit2, path8, fs3, import_mdx_plugins, ElementLikeTypes;
var init_remark_include = __esm({
  "src/loaders/mdx/remark-include.ts"() {
    "use strict";
    import_unified = require("unified");
    import_unist_util_visit2 = require("unist-util-visit");
    path8 = __toESM(require("path"), 1);
    fs3 = __toESM(require("fs/promises"), 1);
    init_fuma_matter();
    import_mdx_plugins = require("fumadocs-core/mdx-plugins");
    init_remark_unravel();
    ElementLikeTypes = [
      "mdxJsxFlowElement",
      "mdxJsxTextElement",
      "containerDirective",
      "textDirective",
      "leafDirective"
    ];
  }
});

// src/loaders/mdx/remark-postprocess.ts
function remarkPostprocess({
  _format,
  includeProcessedMarkdown = false,
  includeMDAST = false,
  valueToExport = []
}) {
  let _stringifyProcessor;
  const getStringifyProcessor = () => {
    if (_format === "mdx") return this;
    return _stringifyProcessor ??= this().use(import_remark_mdx.default).freeze();
  };
  return (tree, file) => {
    let title;
    const urls = [];
    (0, import_unist_util_visit3.visit)(tree, ["heading", "link"], (node) => {
      if (node.type === "heading" && node.depth === 1) {
        title = flattenNode2(node);
      }
      if (node.type !== "link") return;
      urls.push({
        href: node.url
      });
      return "skip";
    });
    if (title) {
      file.data.frontmatter ??= {};
      if (!file.data.frontmatter.title) file.data.frontmatter.title = title;
    }
    file.data.extractedReferences = urls;
    if (includeProcessedMarkdown) {
      const processor = getStringifyProcessor();
      file.data._markdown = (0, import_mdast_util_to_markdown.toMarkdown)(tree, {
        ...processor.data("settings"),
        // from https://github.com/remarkjs/remark/blob/main/packages/remark-stringify/lib/index.js
        extensions: processor.data("toMarkdownExtensions") || []
      });
    }
    if (includeMDAST) {
      const options = includeMDAST === true ? {} : includeMDAST;
      file.data._mdast = JSON.stringify(
        options.removePosition ? (0, import_unist_util_remove_position.removePosition)(structuredClone(tree)) : tree
      );
    }
    for (const { name, value } of file.data["mdx-export"] ?? []) {
      tree.children.unshift(getMdastExport(name, value));
    }
    for (const name of valueToExport) {
      if (!(name in file.data)) continue;
      tree.children.unshift(getMdastExport(name, file.data[name]));
    }
  };
}
function getMdastExport(name, value) {
  return {
    type: "mdxjsEsm",
    value: "",
    data: {
      estree: {
        type: "Program",
        sourceType: "module",
        body: [
          {
            type: "ExportNamedDeclaration",
            attributes: [],
            specifiers: [],
            source: null,
            declaration: {
              type: "VariableDeclaration",
              kind: "let",
              declarations: [
                {
                  type: "VariableDeclarator",
                  id: {
                    type: "Identifier",
                    name
                  },
                  init: (0, import_estree_util_value_to_estree.valueToEstree)(value)
                }
              ]
            }
          }
        ]
      }
    }
  };
}
function flattenNode2(node) {
  if ("children" in node)
    return node.children.map((child) => flattenNode2(child)).join("");
  if ("value" in node) return node.value;
  return "";
}
var import_unist_util_visit3, import_mdast_util_to_markdown, import_estree_util_value_to_estree, import_unist_util_remove_position, import_remark_mdx;
var init_remark_postprocess = __esm({
  "src/loaders/mdx/remark-postprocess.ts"() {
    "use strict";
    import_unist_util_visit3 = require("unist-util-visit");
    import_mdast_util_to_markdown = require("mdast-util-to-markdown");
    import_estree_util_value_to_estree = require("estree-util-value-to-estree");
    import_unist_util_remove_position = require("unist-util-remove-position");
    import_remark_mdx = __toESM(require("remark-mdx"), 1);
  }
});

// src/loaders/mdx/build-mdx.ts
async function buildMDX(cacheKey, source, options) {
  const { filePath, frontmatter, data, _compiler, ...rest } = options;
  function getProcessor(format) {
    const key = `${cacheKey}:${format}`;
    let processor = cache2.get(key);
    if (!processor) {
      processor = (0, import_mdx.createProcessor)({
        outputFormat: "program",
        ...rest,
        remarkPlugins: [
          remarkInclude,
          ...rest.remarkPlugins ?? [],
          [
            remarkPostprocess,
            {
              _format: format,
              ...options.postprocess,
              valueToExport: [
                ...options.postprocess?.valueToExport ?? [],
                "structuredData",
                "extractedReferences",
                "frontmatter",
                "lastModified",
                "_markdown",
                "_mdast"
              ]
            }
          ]
        ],
        format
      });
      cache2.set(key, processor);
    }
    return processor;
  }
  return getProcessor(
    options.format ?? (filePath.endsWith(".mdx") ? "mdx" : "md")
  ).process({
    value: source,
    path: filePath,
    data: {
      ...data,
      frontmatter,
      _compiler,
      _getProcessor: getProcessor
    }
  });
}
var import_mdx, cache2;
var init_build_mdx = __esm({
  "src/loaders/mdx/build-mdx.ts"() {
    "use strict";
    import_mdx = require("@mdx-js/mdx");
    init_remark_include();
    init_remark_postprocess();
    cache2 = /* @__PURE__ */ new Map();
  }
});

// src/loaders/mdx/index.ts
function createMdxLoader(configLoader) {
  return {
    test: mdxLoaderGlob,
    async load({
      getSource,
      development: isDevelopment,
      query,
      compiler,
      filePath
    }) {
      const value = await getSource();
      const matter = fumaMatter(value);
      const parsed = querySchema.parse(query);
      const config = await configLoader.getConfig();
      let after;
      if (!isDevelopment && config.global.experimentalBuildCache) {
        const cacheDir = config.global.experimentalBuildCache;
        const cacheKey = `${parsed.hash}_${parsed.collection ?? "global"}_${generateCacheHash(filePath)}`;
        const cached = await import_promises3.default.readFile(import_node_path5.default.join(cacheDir, cacheKey)).then((content) => cacheEntry.parse(JSON.parse(content.toString()))).catch(() => null);
        if (cached && cached.hash === generateCacheHash(value)) return cached;
        after = async () => {
          await import_promises3.default.mkdir(cacheDir, { recursive: true });
          await import_promises3.default.writeFile(
            import_node_path5.default.join(cacheDir, cacheKey),
            JSON.stringify({
              ...out,
              hash: generateCacheHash(value)
            })
          );
        };
      }
      const collection = parsed.collection ? config.getCollection(parsed.collection) : void 0;
      let docCollection;
      switch (collection?.type) {
        case "doc":
          docCollection = collection;
          break;
        case "docs":
          docCollection = collection.docs;
          break;
      }
      if (docCollection?.schema) {
        matter.data = await validate(
          docCollection.schema,
          matter.data,
          {
            source: value,
            path: filePath
          },
          `invalid frontmatter in ${filePath}`
        );
      }
      if (parsed.only === "frontmatter") {
        return {
          code: `export const frontmatter = ${JSON.stringify(matter.data)}`,
          map: null
        };
      }
      const data = {};
      if (config.global.lastModifiedTime === "git") {
        data.lastModified = (await getGitTimestamp(filePath))?.getTime();
      }
      const lineOffset = isDevelopment ? countLines(matter.matter) : 0;
      const compiled = await buildMDX(
        `${getConfigHash(config)}:${parsed.collection ?? "global"}`,
        "\n".repeat(lineOffset) + matter.content,
        {
          development: isDevelopment,
          ...docCollection?.mdxOptions ?? await config.getDefaultMDXOptions(),
          postprocess: docCollection?.postprocess,
          data,
          filePath,
          frontmatter: matter.data,
          _compiler: compiler
        }
      );
      const out = {
        code: String(compiled.value),
        map: compiled.map
      };
      await after?.();
      return out;
    }
  };
}
function getConfigHash(config) {
  let hash = hashes.get(config);
  if (hash) return hash;
  hash = Date.now().toString();
  hashes.set(config, hash);
  return hash;
}
function generateCacheHash(input) {
  return (0, import_node_crypto2.createHash)("md5").update(input).digest("hex");
}
function countLines(s) {
  let num = 0;
  for (const c of s) {
    if (c === "\n") num++;
  }
  return num;
}
var import_zod, import_promises3, import_node_path5, import_node_crypto2, querySchema, cacheEntry, hashes;
var init_mdx = __esm({
  "src/loaders/mdx/index.ts"() {
    "use strict";
    init_fuma_matter();
    init_validation();
    init_git_timestamp();
    init_build_mdx();
    import_zod = require("zod");
    import_promises3 = __toESM(require("fs/promises"), 1);
    import_node_path5 = __toESM(require("path"), 1);
    import_node_crypto2 = require("crypto");
    init_loaders();
    querySchema = import_zod.z.object({
      only: import_zod.z.literal(["frontmatter", "all"]).default("all"),
      collection: import_zod.z.string().optional()
    }).loose();
    cacheEntry = import_zod.z.object({
      code: import_zod.z.string(),
      map: import_zod.z.any().optional(),
      hash: import_zod.z.string().optional()
    });
    hashes = /* @__PURE__ */ new WeakMap();
  }
});

// src/loaders/adapter.ts
function toVite(loader) {
  return {
    filter(id) {
      return !loader.test || loader.test.test(id);
    },
    async transform(value, id) {
      const [file, query = ""] = id.split("?", 2);
      const result = await loader.load({
        filePath: file,
        query: (0, import_node_querystring.parse)(query),
        getSource() {
          return value;
        },
        development: this.environment.mode === "dev",
        compiler: {
          addDependency: (file2) => {
            this.addWatchFile(file2);
          }
        }
      });
      if (result === null) return null;
      return {
        code: result.code,
        map: result.map
      };
    }
  };
}
var import_node_url2, import_promises4, import_node_querystring, import_node_path6;
var init_adapter = __esm({
  "src/loaders/adapter.ts"() {
    "use strict";
    import_node_url2 = require("url");
    import_promises4 = __toESM(require("fs/promises"), 1);
    import_node_querystring = require("querystring");
    init_validation();
    import_node_path6 = __toESM(require("path"), 1);
  }
});

// src/utils/glob-import.ts
function generateGlobImport(patterns, options) {
  let code = "{";
  const result = (0, import_tinyglobby.globSync)(patterns, {
    cwd: options.base
  });
  for (const item of result) {
    const fullPath = import_node_path7.default.join(options.base, item);
    const url = (0, import_node_url3.pathToFileURL)(fullPath);
    for (const [k, v] of Object.entries(options.query ?? {})) {
      url.searchParams.set(k, v);
    }
    let line = `${JSON.stringify(item)}: () => import(${JSON.stringify(url.href)})`;
    if (options.import) {
      line += `.then(mod => mod[${JSON.stringify(options.import)}])`;
    }
    code += `${line}, `;
  }
  code += "}";
  return code;
}
var import_tinyglobby, import_node_path7, import_node_url3;
var init_glob_import = __esm({
  "src/utils/glob-import.ts"() {
    "use strict";
    import_tinyglobby = require("tinyglobby");
    import_node_path7 = __toESM(require("path"), 1);
    import_node_url3 = require("url");
  }
});

// src/plugins/vite.ts
function vite({
  index
}) {
  let config;
  let indexOptions;
  if (index === false) indexOptions = false;
  else indexOptions = applyDefaults2(index === true ? {} : index);
  return {
    name: "vite",
    config(v) {
      config = v;
    },
    configureServer(server) {
      if (!server.watcher || indexOptions === false || indexOptions.runtime === false)
        return;
      server.watcher.on("all", (event, file) => {
        if (event === "change") return;
        const isUpdated = config.collectionList.some((collection) => {
          if (collection.type === "docs")
            return collection.docs.hasFile(file) || collection.meta.hasFile(file);
          return collection.hasFile(file);
        });
        if (isUpdated) {
          this.core.emitAndWrite({
            filterPlugin: (plugin) => plugin.name === "vite"
          });
        }
      });
    },
    emit() {
      const out = [];
      if (indexOptions === false) return out;
      if (indexOptions.browser) {
        out.push({
          path: "browser.ts",
          content: indexFile2(this, config, indexOptions, "browser")
        });
      }
      out.push({
        path: "index.ts",
        content: indexFile2(
          this,
          config,
          indexOptions,
          indexOptions.browser ? "server" : "all"
        )
      });
      return out;
    }
  };
}
function applyDefaults2(options) {
  return {
    addJsExtension: options.addJsExtension ?? false,
    browser: options.browser ?? false,
    runtime: options.runtime ?? false
  };
}
function indexFile2({ configPath, outDir }, config, { addJsExtension, runtime }, environment) {
  const runtimePath = {
    all: "fumadocs-mdx/runtime/vite",
    server: "fumadocs-mdx/runtime/vite.server",
    browser: "fumadocs-mdx/runtime/vite.browser"
  }[environment];
  const lines = [
    '/// <reference types="vite/client" />',
    `import { fromConfig } from '${runtimePath}';`,
    `import type * as Config from '${toImportPath(configPath, {
      relativeTo: outDir,
      jsExtension: addJsExtension
    })}';`,
    "",
    `export const create = fromConfig<typeof Config>();`
  ];
  function generateCollectionGlob(collection) {
    if (collection.type === "docs") {
      const obj = [
        ident(`doc: ${generateCollectionGlob(collection.docs)}`),
        ident(`meta: ${generateCollectionGlob(collection.meta)}`)
      ].join(",\n");
      return `{
${obj}
}`;
    }
    const dir = getCollectionDir(collection);
    if (collection.type === "doc") {
      const docGlob = generateGlob(collection.patterns, {
        query: {
          collection: collection.name
        },
        base: dir
      });
      if (collection.async) {
        const headBlob = generateGlob(collection.patterns, {
          query: {
            only: "frontmatter",
            collection: collection.name
          },
          import: "frontmatter",
          base: dir
        });
        return `create.docLazy("${collection.name}", "${dir}", ${headBlob}, ${docGlob})`;
      }
      return `create.doc("${collection.name}", "${dir}", ${docGlob})`;
    }
    return `create.meta("${collection.name}", "${dir}", ${generateGlob(
      collection.patterns,
      {
        import: "default",
        base: dir,
        query: {
          collection: collection.name
        }
      }
    )})`;
  }
  function generateGlob(patterns, options) {
    patterns = patterns.map(normalizeGlobPath);
    if (runtime === "node" || runtime === "bun") {
      return generateGlobImport(patterns, options);
    } else {
      return `import.meta.glob(${JSON.stringify(patterns)}, ${JSON.stringify(
        {
          ...options,
          base: normalizeGlobPath(import_node_path8.default.relative(outDir, options.base))
        },
        null,
        2
      )})`;
    }
  }
  for (const collection of config.collectionList) {
    lines.push("");
    lines.push(
      `export const ${collection.name} = ${generateCollectionGlob(collection)};`
    );
  }
  return lines.join("\n");
}
function normalizeGlobPath(file) {
  file = slash(file);
  if (file.startsWith("./")) return file;
  if (file.startsWith("/")) return `.${file}`;
  return `./${file}`;
}
function getCollectionDir({ dir }) {
  if (Array.isArray(dir)) {
    if (dir.length !== 1)
      throw new Error(
        `[Fumadocs MDX] Vite Plugin doesn't support multiple \`dir\` for a collection at the moment.`
      );
    return dir[0];
  }
  return dir;
}
function slash(path13) {
  const isExtendedLengthPath = path13.startsWith("\\\\?\\");
  if (isExtendedLengthPath) {
    return path13;
  }
  return path13.replaceAll("\\", "/");
}
var import_node_path8;
var init_vite = __esm({
  "src/plugins/vite.ts"() {
    "use strict";
    init_import_formatter();
    init_glob_import();
    import_node_path8 = __toESM(require("path"), 1);
  }
});

// src/loaders/config.ts
function createIntegratedConfigLoader(core) {
  return {
    getConfig() {
      return core.getConfig();
    }
  };
}
var import_promises5;
var init_config = __esm({
  "src/loaders/config.ts"() {
    "use strict";
    import_promises5 = __toESM(require("fs/promises"), 1);
  }
});

// src/loaders/meta.ts
function createMetaLoader(configLoader, resolve5 = {}) {
  const { json: resolveJson = "js", yaml: resolveYaml = "js" } = resolve5;
  function stringifyOutput(isJson, data) {
    if (isJson) {
      return resolveJson === "json" ? JSON.stringify(data) : `export default ${JSON.stringify(data)}`;
    } else {
      return resolveYaml === "yaml" ? (0, import_js_yaml3.dump)(data) : `export default ${JSON.stringify(data)}`;
    }
  }
  return {
    test: metaLoaderGlob,
    async load({ filePath, query, getSource }) {
      const parsed = querySchema2.parse(query);
      const collection = parsed.collection ? (await configLoader.getConfig()).getCollection(parsed.collection) : void 0;
      if (!collection) return null;
      const isJson = filePath.endsWith(".json");
      const source = await getSource();
      let data;
      try {
        data = isJson ? JSON.parse(source) : (0, import_js_yaml3.load)(source);
      } catch (e) {
        throw new Error(`invalid data in ${filePath}`, { cause: e });
      }
      let schema;
      switch (collection?.type) {
        case "meta":
          schema = collection.schema;
          break;
        case "docs":
          schema = collection.meta.schema;
          break;
      }
      if (schema) {
        data = await validate(
          schema,
          data,
          { path: filePath, source },
          `invalid data in ${filePath}`
        );
      }
      return {
        code: stringifyOutput(isJson, data)
      };
    },
    bun: {
      async fallback({ getSource, filePath }) {
        const source = await getSource();
        const isJson = filePath.endsWith(".json");
        let data;
        try {
          data = isJson ? JSON.parse(source) : (0, import_js_yaml3.load)(source);
        } catch (e) {
          throw new Error(`invalid data in ${filePath}`, { cause: e });
        }
        return {
          loader: "object",
          exports: data
        };
      }
    }
  };
}
var import_js_yaml3, import_zod2, querySchema2;
var init_meta = __esm({
  "src/loaders/meta.ts"() {
    "use strict";
    import_js_yaml3 = require("js-yaml");
    init_validation();
    import_zod2 = require("zod");
    init_loaders();
    querySchema2 = import_zod2.z.object({
      collection: import_zod2.z.string().optional()
    }).loose();
  }
});

// src/vite/index.ts
var vite_exports = {};
__export(vite_exports, {
  default: () => mdx,
  postInstall: () => postInstall2
});
async function mdx(config, pluginOptions = {}) {
  const options = applyDefaults3(pluginOptions);
  const core = await createViteCore(options).init({
    config: buildConfig(config)
  });
  const configLoader = createIntegratedConfigLoader(core);
  const mdxLoader = toVite(createMdxLoader(configLoader));
  const metaLoader = toVite(
    createMetaLoader(configLoader, {
      // vite has built-in plugin for JSON files
      json: "json"
    })
  );
  return {
    name: "fumadocs-mdx",
    // needed, otherwise other plugins will be executed before our `transform`.
    enforce: "pre",
    config(config2) {
      if (!options.updateViteConfig) return config2;
      return (0, import_vite.mergeConfig)(config2, {
        optimizeDeps: {
          exclude: FumadocsDeps
        },
        resolve: {
          noExternal: FumadocsDeps,
          dedupe: FumadocsDeps
        }
      });
    },
    async buildStart() {
      await core.emitAndWrite();
    },
    async configureServer(server) {
      await core.initServer({
        watcher: server.watcher
      });
    },
    async transform(value, id) {
      try {
        if (metaLoader.filter(id)) {
          return await metaLoader.transform.call(this, value, id);
        }
        if (mdxLoader.filter(id)) {
          return await mdxLoader.transform.call(this, value, id);
        }
      } catch (e) {
        if (e instanceof ValidationError) {
          throw new Error(e.toStringFormatted());
        }
        throw e;
      }
    }
  };
}
async function postInstall2(configPath = findConfigFile(), pluginOptions = {}) {
  const { loadConfig: loadConfig2 } = await Promise.resolve().then(() => (init_load_from_file(), load_from_file_exports));
  const options = applyDefaults3(pluginOptions);
  const core = await createViteCore(options).init({
    config: loadConfig2(configPath, options.outDir, true)
  });
  await core.emitAndWrite();
}
function createViteCore({
  configPath,
  outDir,
  generateIndexFile
}) {
  return createCore(
    {
      environment: "vite",
      configPath,
      outDir
    },
    [
      vite({
        index: generateIndexFile
      })
    ]
  );
}
function applyDefaults3(options) {
  return {
    updateViteConfig: options.updateViteConfig ?? true,
    generateIndexFile: options.generateIndexFile ?? true,
    configPath: options.configPath ?? "source.config.ts",
    outDir: options.outDir ?? ".source"
  };
}
var import_vite, FumadocsDeps;
var init_vite2 = __esm({
  "src/vite/index.ts"() {
    "use strict";
    import_vite = require("vite");
    init_build();
    init_validation();
    init_mdx();
    init_adapter();
    init_vite();
    init_core();
    init_config();
    init_meta();
    FumadocsDeps = ["fumadocs-core", "fumadocs-ui", "fumadocs-openapi"];
  }
});

// src/bin.ts
var import_node_fs = require("fs");
async function start() {
  const [configPath] = process.argv.slice(2);
  const isNext = (0, import_node_fs.existsSync)("next.config.js") || (0, import_node_fs.existsSync)("next.config.mjs") || (0, import_node_fs.existsSync)("next.config.mts") || (0, import_node_fs.existsSync)("next.config.ts");
  if (isNext) {
    const { postInstall: postInstall3 } = await Promise.resolve().then(() => (init_next2(), next_exports));
    await postInstall3(configPath);
  } else {
    const { postInstall: postInstall3 } = await Promise.resolve().then(() => (init_vite2(), vite_exports));
    await postInstall3(configPath);
  }
}
void start();
