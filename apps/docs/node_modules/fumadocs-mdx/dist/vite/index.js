import {
  ident,
  toImportPath
} from "../chunk-CXA4JO4Z.js";
import {
  buildConfig
} from "../chunk-2HXTGJBI.js";
import {
  createMdxLoader
} from "../chunk-2E2JCOSO.js";
import {
  createMetaLoader
} from "../chunk-4757L6ST.js";
import {
  createIntegratedConfigLoader,
  toVite
} from "../chunk-ETIN2W7C.js";
import "../chunk-3J3WL7WN.js";
import "../chunk-K5ZLPEIQ.js";
import "../chunk-VUEZTR2H.js";
import {
  ValidationError,
  createCore,
  findConfigFile
} from "../chunk-2AQRQXSO.js";
import "../chunk-VWJKRQZR.js";

// src/vite/index.ts
import { mergeConfig } from "vite";

// src/utils/glob-import.ts
import { globSync } from "tinyglobby";
import path from "path";
import { pathToFileURL } from "url";
function generateGlobImport(patterns, options) {
  let code = "{";
  const result = globSync(patterns, {
    cwd: options.base
  });
  for (const item of result) {
    const fullPath = path.join(options.base, item);
    const url = pathToFileURL(fullPath);
    for (const [k, v] of Object.entries(options.query ?? {})) {
      url.searchParams.set(k, v);
    }
    let line = `${JSON.stringify(item)}: () => import(${JSON.stringify(url.href)})`;
    if (options.import) {
      line += `.then(mod => mod[${JSON.stringify(options.import)}])`;
    }
    code += `${line}, `;
  }
  code += "}";
  return code;
}

// src/plugins/vite.ts
import path2 from "path";
function vite({
  index
}) {
  let config;
  let indexOptions;
  if (index === false) indexOptions = false;
  else indexOptions = applyDefaults(index === true ? {} : index);
  return {
    name: "vite",
    config(v) {
      config = v;
    },
    configureServer(server) {
      if (!server.watcher || indexOptions === false || indexOptions.runtime === false)
        return;
      server.watcher.on("all", (event, file) => {
        if (event === "change") return;
        const isUpdated = config.collectionList.some((collection) => {
          if (collection.type === "docs")
            return collection.docs.hasFile(file) || collection.meta.hasFile(file);
          return collection.hasFile(file);
        });
        if (isUpdated) {
          this.core.emitAndWrite({
            filterPlugin: (plugin) => plugin.name === "vite"
          });
        }
      });
    },
    emit() {
      const out = [];
      if (indexOptions === false) return out;
      if (indexOptions.browser) {
        out.push({
          path: "browser.ts",
          content: indexFile(this, config, indexOptions, "browser")
        });
      }
      out.push({
        path: "index.ts",
        content: indexFile(
          this,
          config,
          indexOptions,
          indexOptions.browser ? "server" : "all"
        )
      });
      return out;
    }
  };
}
function applyDefaults(options) {
  return {
    addJsExtension: options.addJsExtension ?? false,
    browser: options.browser ?? false,
    runtime: options.runtime ?? false
  };
}
function indexFile({ configPath, outDir }, config, { addJsExtension, runtime }, environment) {
  const runtimePath = {
    all: "fumadocs-mdx/runtime/vite",
    server: "fumadocs-mdx/runtime/vite.server",
    browser: "fumadocs-mdx/runtime/vite.browser"
  }[environment];
  const lines = [
    '/// <reference types="vite/client" />',
    `import { fromConfig } from '${runtimePath}';`,
    `import type * as Config from '${toImportPath(configPath, {
      relativeTo: outDir,
      jsExtension: addJsExtension
    })}';`,
    "",
    `export const create = fromConfig<typeof Config>();`
  ];
  function generateCollectionGlob(collection) {
    if (collection.type === "docs") {
      const obj = [
        ident(`doc: ${generateCollectionGlob(collection.docs)}`),
        ident(`meta: ${generateCollectionGlob(collection.meta)}`)
      ].join(",\n");
      return `{
${obj}
}`;
    }
    const dir = getCollectionDir(collection);
    if (collection.type === "doc") {
      const docGlob = generateGlob(collection.patterns, {
        query: {
          collection: collection.name
        },
        base: dir
      });
      if (collection.async) {
        const headBlob = generateGlob(collection.patterns, {
          query: {
            only: "frontmatter",
            collection: collection.name
          },
          import: "frontmatter",
          base: dir
        });
        return `create.docLazy("${collection.name}", "${dir}", ${headBlob}, ${docGlob})`;
      }
      return `create.doc("${collection.name}", "${dir}", ${docGlob})`;
    }
    return `create.meta("${collection.name}", "${dir}", ${generateGlob(
      collection.patterns,
      {
        import: "default",
        base: dir,
        query: {
          collection: collection.name
        }
      }
    )})`;
  }
  function generateGlob(patterns, options) {
    patterns = patterns.map(normalizeGlobPath);
    if (runtime === "node" || runtime === "bun") {
      return generateGlobImport(patterns, options);
    } else {
      return `import.meta.glob(${JSON.stringify(patterns)}, ${JSON.stringify(
        {
          ...options,
          base: normalizeGlobPath(path2.relative(outDir, options.base))
        },
        null,
        2
      )})`;
    }
  }
  for (const collection of config.collectionList) {
    lines.push("");
    lines.push(
      `export const ${collection.name} = ${generateCollectionGlob(collection)};`
    );
  }
  return lines.join("\n");
}
function normalizeGlobPath(file) {
  file = slash(file);
  if (file.startsWith("./")) return file;
  if (file.startsWith("/")) return `.${file}`;
  return `./${file}`;
}
function getCollectionDir({ dir }) {
  if (Array.isArray(dir)) {
    if (dir.length !== 1)
      throw new Error(
        `[Fumadocs MDX] Vite Plugin doesn't support multiple \`dir\` for a collection at the moment.`
      );
    return dir[0];
  }
  return dir;
}
function slash(path3) {
  const isExtendedLengthPath = path3.startsWith("\\\\?\\");
  if (isExtendedLengthPath) {
    return path3;
  }
  return path3.replaceAll("\\", "/");
}

// src/vite/index.ts
var FumadocsDeps = ["fumadocs-core", "fumadocs-ui", "fumadocs-openapi"];
async function mdx(config, pluginOptions = {}) {
  const options = applyDefaults2(pluginOptions);
  const core = await createViteCore(options).init({
    config: buildConfig(config)
  });
  const configLoader = createIntegratedConfigLoader(core);
  const mdxLoader = toVite(createMdxLoader(configLoader));
  const metaLoader = toVite(
    createMetaLoader(configLoader, {
      // vite has built-in plugin for JSON files
      json: "json"
    })
  );
  return {
    name: "fumadocs-mdx",
    // needed, otherwise other plugins will be executed before our `transform`.
    enforce: "pre",
    config(config2) {
      if (!options.updateViteConfig) return config2;
      return mergeConfig(config2, {
        optimizeDeps: {
          exclude: FumadocsDeps
        },
        resolve: {
          noExternal: FumadocsDeps,
          dedupe: FumadocsDeps
        }
      });
    },
    async buildStart() {
      await core.emitAndWrite();
    },
    async configureServer(server) {
      await core.initServer({
        watcher: server.watcher
      });
    },
    async transform(value, id) {
      try {
        if (metaLoader.filter(id)) {
          return await metaLoader.transform.call(this, value, id);
        }
        if (mdxLoader.filter(id)) {
          return await mdxLoader.transform.call(this, value, id);
        }
      } catch (e) {
        if (e instanceof ValidationError) {
          throw new Error(e.toStringFormatted());
        }
        throw e;
      }
    }
  };
}
async function postInstall(configPath = findConfigFile(), pluginOptions = {}) {
  const { loadConfig } = await import("../load-from-file-AVYOFOI7.js");
  const options = applyDefaults2(pluginOptions);
  const core = await createViteCore(options).init({
    config: loadConfig(configPath, options.outDir, true)
  });
  await core.emitAndWrite();
}
function createViteCore({
  configPath,
  outDir,
  generateIndexFile
}) {
  return createCore(
    {
      environment: "vite",
      configPath,
      outDir
    },
    [
      vite({
        index: generateIndexFile
      })
    ]
  );
}
function applyDefaults2(options) {
  return {
    updateViteConfig: options.updateViteConfig ?? true,
    generateIndexFile: options.generateIndexFile ?? true,
    configPath: options.configPath ?? "source.config.ts",
    outDir: options.outDir ?? ".source"
  };
}
export {
  mdx as default,
  postInstall
};
