// src/config/build.ts
import picomatch from "picomatch";
var SupportedFormats = {
  doc: ["mdx", "md"],
  meta: ["json", "yaml"]
};
function buildCollection(name, config) {
  if (config.type === "docs") {
    return {
      ...config,
      name,
      meta: buildPrimitiveCollection(name, config.meta),
      docs: buildPrimitiveCollection(name, config.docs)
    };
  }
  return buildPrimitiveCollection(name, config);
}
function buildPrimitiveCollection(name, { files, ...config }) {
  const supportedFormats = SupportedFormats[config.type];
  const patterns = files ?? [`**/*.{${supportedFormats.join(",")}}`];
  let matchers;
  return {
    ...config,
    name,
    patterns,
    isFileSupported(filePath) {
      return supportedFormats.some((format) => filePath.endsWith(`.${format}`));
    },
    hasFile(filePath) {
      matchers ??= (Array.isArray(config.dir) ? config.dir : [config.dir]).map(
        (dir) => picomatch(patterns, {
          cwd: dir
        })
      );
      return this.isFileSupported(filePath) && matchers.some((matcher) => matcher(filePath));
    }
  };
}
function buildConfig(config) {
  const collections = /* @__PURE__ */ new Map();
  const loaded = {};
  for (const [k, v] of Object.entries(config)) {
    if (!v) {
      continue;
    }
    if (typeof v === "object" && "type" in v) {
      if (v.type === "docs") {
        collections.set(k, buildCollection(k, v));
        continue;
      }
      if (v.type === "doc" || v.type === "meta") {
        collections.set(
          k,
          buildCollection(k, v)
        );
        continue;
      }
    }
    if (k === "default" && v) {
      Object.assign(loaded, v);
      continue;
    }
    throw new Error(
      `Unknown export "${k}", you can only export collections from source configuration file.`
    );
  }
  if (loaded.collections) {
    for (const [k, v] of Object.entries(loaded.collections)) {
      collections.set(k, buildCollection(k, v));
    }
  }
  const mdxOptionsCache = /* @__PURE__ */ new Map();
  return {
    global: loaded,
    collectionList: Array.from(collections.values()),
    getCollection(name) {
      return collections.get(name);
    },
    async getDefaultMDXOptions(mode = "default") {
      const cached = mdxOptionsCache.get(mode);
      if (cached) return cached;
      const input = this.global.mdxOptions;
      async function uncached() {
        const options = typeof input === "function" ? await input() : input;
        const { getDefaultMDXOptions } = await import("./preset-ZMP6U62C.js");
        if (options?.preset === "minimal") return options;
        return getDefaultMDXOptions({
          ...options,
          _withoutBundler: mode === "remote"
        });
      }
      const result = uncached();
      mdxOptionsCache.set(mode, result);
      return result;
    }
  };
}

export {
  buildConfig
};
