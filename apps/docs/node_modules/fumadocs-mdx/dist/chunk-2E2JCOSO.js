import {
  buildMDX
} from "./chunk-3J3WL7WN.js";
import {
  getGitTimestamp
} from "./chunk-VUEZTR2H.js";
import {
  mdxLoaderGlob,
  validate
} from "./chunk-2AQRQXSO.js";
import {
  fumaMatter
} from "./chunk-VWJKRQZR.js";

// src/loaders/mdx/index.ts
import { z } from "zod";
import fs from "fs/promises";
import path from "path";
import { createHash } from "crypto";
var querySchema = z.object({
  only: z.literal(["frontmatter", "all"]).default("all"),
  collection: z.string().optional()
}).loose();
var cacheEntry = z.object({
  code: z.string(),
  map: z.any().optional(),
  hash: z.string().optional()
});
function createMdxLoader(configLoader) {
  return {
    test: mdxLoaderGlob,
    async load({
      getSource,
      development: isDevelopment,
      query,
      compiler,
      filePath
    }) {
      const value = await getSource();
      const matter = fumaMatter(value);
      const parsed = querySchema.parse(query);
      const config = await configLoader.getConfig();
      let after;
      if (!isDevelopment && config.global.experimentalBuildCache) {
        const cacheDir = config.global.experimentalBuildCache;
        const cacheKey = `${parsed.hash}_${parsed.collection ?? "global"}_${generateCacheHash(filePath)}`;
        const cached = await fs.readFile(path.join(cacheDir, cacheKey)).then((content) => cacheEntry.parse(JSON.parse(content.toString()))).catch(() => null);
        if (cached && cached.hash === generateCacheHash(value)) return cached;
        after = async () => {
          await fs.mkdir(cacheDir, { recursive: true });
          await fs.writeFile(
            path.join(cacheDir, cacheKey),
            JSON.stringify({
              ...out,
              hash: generateCacheHash(value)
            })
          );
        };
      }
      const collection = parsed.collection ? config.getCollection(parsed.collection) : void 0;
      let docCollection;
      switch (collection?.type) {
        case "doc":
          docCollection = collection;
          break;
        case "docs":
          docCollection = collection.docs;
          break;
      }
      if (docCollection?.schema) {
        matter.data = await validate(
          docCollection.schema,
          matter.data,
          {
            source: value,
            path: filePath
          },
          `invalid frontmatter in ${filePath}`
        );
      }
      if (parsed.only === "frontmatter") {
        return {
          code: `export const frontmatter = ${JSON.stringify(matter.data)}`,
          map: null
        };
      }
      const data = {};
      if (config.global.lastModifiedTime === "git") {
        data.lastModified = (await getGitTimestamp(filePath))?.getTime();
      }
      const lineOffset = isDevelopment ? countLines(matter.matter) : 0;
      const compiled = await buildMDX(
        `${getConfigHash(config)}:${parsed.collection ?? "global"}`,
        "\n".repeat(lineOffset) + matter.content,
        {
          development: isDevelopment,
          ...docCollection?.mdxOptions ?? await config.getDefaultMDXOptions(),
          postprocess: docCollection?.postprocess,
          data,
          filePath,
          frontmatter: matter.data,
          _compiler: compiler
        }
      );
      const out = {
        code: String(compiled.value),
        map: compiled.map
      };
      await after?.();
      return out;
    }
  };
}
var hashes = /* @__PURE__ */ new WeakMap();
function getConfigHash(config) {
  let hash = hashes.get(config);
  if (hash) return hash;
  hash = Date.now().toString();
  hashes.set(config, hash);
  return hash;
}
function generateCacheHash(input) {
  return createHash("md5").update(input).digest("hex");
}
function countLines(s) {
  let num = 0;
  for (const c of s) {
    if (c === "\n") num++;
  }
  return num;
}

export {
  createMdxLoader
};
