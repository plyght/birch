"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/loaders/mdx/preset.ts
var preset_exports = {};
__export(preset_exports, {
  getDefaultMDXOptions: () => getDefaultMDXOptions
});
function pluginOption(def, options = []) {
  const list = def(Array.isArray(options) ? options : []).filter(
    Boolean
  );
  if (typeof options === "function") {
    return options(list);
  }
  return list;
}
function getDefaultMDXOptions({
  valueToExport = [],
  rehypeCodeOptions,
  remarkImageOptions,
  remarkHeadingOptions,
  remarkStructureOptions,
  remarkCodeTabOptions,
  remarkNpmOptions,
  _withoutBundler = false,
  ...mdxOptions
}) {
  const remarkPlugins = pluginOption(
    (v) => [
      plugins.remarkGfm,
      [
        plugins.remarkHeading,
        {
          generateToc: false,
          ...remarkHeadingOptions
        }
      ],
      remarkImageOptions !== false && [
        plugins.remarkImage,
        {
          ...remarkImageOptions,
          useImport: _withoutBundler ? false : remarkImageOptions?.useImport
        }
      ],
      "remarkCodeTab" in plugins && remarkCodeTabOptions !== false && [
        plugins.remarkCodeTab,
        remarkCodeTabOptions
      ],
      "remarkNpm" in plugins && remarkNpmOptions !== false && [plugins.remarkNpm, remarkNpmOptions],
      ...v,
      remarkStructureOptions !== false && [
        plugins.remarkStructure,
        remarkStructureOptions
      ],
      () => {
        return (_, file) => {
          file.data["mdx-export"] ??= [];
          for (const name of valueToExport) {
            if (name in file.data)
              file.data["mdx-export"].push({ name, value: file.data[name] });
          }
        };
      }
    ],
    mdxOptions.remarkPlugins
  );
  const rehypePlugins = pluginOption(
    (v) => [
      rehypeCodeOptions !== false && [plugins.rehypeCode, rehypeCodeOptions],
      ...v,
      plugins.rehypeToc
    ],
    mdxOptions.rehypePlugins
  );
  return {
    ...mdxOptions,
    outputFormat: _withoutBundler ? "function-body" : mdxOptions.outputFormat,
    remarkPlugins,
    rehypePlugins
  };
}
var plugins;
var init_preset = __esm({
  "src/loaders/mdx/preset.ts"() {
    "use strict";
    plugins = __toESM(require("fumadocs-core/mdx-plugins"), 1);
  }
});

// src/config/build.ts
function buildCollection(name, config) {
  if (config.type === "docs") {
    return {
      ...config,
      name,
      meta: buildPrimitiveCollection(name, config.meta),
      docs: buildPrimitiveCollection(name, config.docs)
    };
  }
  return buildPrimitiveCollection(name, config);
}
function buildPrimitiveCollection(name, { files, ...config }) {
  const supportedFormats = SupportedFormats[config.type];
  const patterns = files ?? [`**/*.{${supportedFormats.join(",")}}`];
  let matchers;
  return {
    ...config,
    name,
    patterns,
    isFileSupported(filePath) {
      return supportedFormats.some((format) => filePath.endsWith(`.${format}`));
    },
    hasFile(filePath) {
      matchers ??= (Array.isArray(config.dir) ? config.dir : [config.dir]).map(
        (dir) => (0, import_picomatch.default)(patterns, {
          cwd: dir
        })
      );
      return this.isFileSupported(filePath) && matchers.some((matcher) => matcher(filePath));
    }
  };
}
function buildConfig(config) {
  const collections = /* @__PURE__ */ new Map();
  const loaded = {};
  for (const [k, v] of Object.entries(config)) {
    if (!v) {
      continue;
    }
    if (typeof v === "object" && "type" in v) {
      if (v.type === "docs") {
        collections.set(k, buildCollection(k, v));
        continue;
      }
      if (v.type === "doc" || v.type === "meta") {
        collections.set(
          k,
          buildCollection(k, v)
        );
        continue;
      }
    }
    if (k === "default" && v) {
      Object.assign(loaded, v);
      continue;
    }
    throw new Error(
      `Unknown export "${k}", you can only export collections from source configuration file.`
    );
  }
  if (loaded.collections) {
    for (const [k, v] of Object.entries(loaded.collections)) {
      collections.set(k, buildCollection(k, v));
    }
  }
  const mdxOptionsCache = /* @__PURE__ */ new Map();
  return {
    global: loaded,
    collectionList: Array.from(collections.values()),
    getCollection(name) {
      return collections.get(name);
    },
    async getDefaultMDXOptions(mode = "default") {
      const cached = mdxOptionsCache.get(mode);
      if (cached) return cached;
      const input = this.global.mdxOptions;
      async function uncached() {
        const options = typeof input === "function" ? await input() : input;
        const { getDefaultMDXOptions: getDefaultMDXOptions2 } = await Promise.resolve().then(() => (init_preset(), preset_exports));
        if (options?.preset === "minimal") return options;
        return getDefaultMDXOptions2({
          ...options,
          _withoutBundler: mode === "remote"
        });
      }
      const result = uncached();
      mdxOptionsCache.set(mode, result);
      return result;
    }
  };
}
var import_picomatch, SupportedFormats;
var init_build = __esm({
  "src/config/build.ts"() {
    "use strict";
    import_picomatch = __toESM(require("picomatch"), 1);
    SupportedFormats = {
      doc: ["mdx", "md"],
      meta: ["json", "yaml"]
    };
  }
});

// src/config/load-from-file.ts
var load_from_file_exports = {};
__export(load_from_file_exports, {
  loadConfig: () => loadConfig
});
async function compileConfig(configPath, outDir) {
  const { build } = await import("esbuild");
  const transformed = await build({
    entryPoints: [{ in: configPath, out: "source.config" }],
    bundle: true,
    outdir: outDir,
    target: "node20",
    write: true,
    platform: "node",
    format: "esm",
    packages: "external",
    outExtension: {
      ".js": ".mjs"
    },
    allowOverwrite: true
  });
  if (transformed.errors.length > 0) {
    throw new Error("failed to compile configuration file");
  }
}
async function loadConfig(configPath, outDir, build = false) {
  if (build) await compileConfig(configPath, outDir);
  const url = (0, import_node_url2.pathToFileURL)(path3.resolve(outDir, "source.config.mjs"));
  url.searchParams.set("hash", Date.now().toString());
  const config = import(url.href).then(
    (loaded) => buildConfig(loaded)
  );
  return await config;
}
var path3, import_node_url2;
var init_load_from_file = __esm({
  "src/config/load-from-file.ts"() {
    "use strict";
    path3 = __toESM(require("path"), 1);
    import_node_url2 = require("url");
    init_build();
  }
});

// src/webpack/meta.ts
var meta_exports = {};
__export(meta_exports, {
  default: () => loader
});
module.exports = __toCommonJS(meta_exports);

// src/loaders/adapter.ts
var import_node_url = require("url");
var import_promises = __toESM(require("fs/promises"), 1);
var import_node_querystring = require("querystring");

// src/utils/validation.ts
var import_picocolors = __toESM(require("picocolors"), 1);
var ValidationError = class extends Error {
  constructor(message, issues) {
    super(
      `${message}:
${issues.map((issue) => `  ${issue.path}: ${issue.message}`).join("\n")}`
    );
    this.title = message;
    this.issues = issues;
  }
  toStringFormatted() {
    return [
      import_picocolors.default.bold(`[MDX] ${this.title}:`),
      ...this.issues.map(
        (issue) => import_picocolors.default.redBright(
          `- ${import_picocolors.default.bold(issue.path?.join(".") ?? "*")}: ${issue.message}`
        )
      )
    ].join("\n");
  }
};
async function validate(schema, data, context, errorMessage) {
  if (typeof schema === "function" && !("~standard" in schema)) {
    schema = schema(context);
  }
  if ("~standard" in schema) {
    const result = await schema["~standard"].validate(
      data
    );
    if (result.issues) {
      throw new ValidationError(errorMessage, result.issues);
    }
    return result.value;
  }
  return data;
}

// src/loaders/adapter.ts
var import_node_path = __toESM(require("path"), 1);
function toWebpack(loader2) {
  return async function(source, callback) {
    try {
      const result = await loader2.load({
        filePath: this.resourcePath,
        query: (0, import_node_querystring.parse)(this.resourceQuery.slice(1)),
        getSource() {
          return source;
        },
        development: this.mode === "development",
        compiler: this
      });
      if (result === null) {
        callback(void 0, source);
      } else {
        callback(void 0, result.code, result.map);
      }
    } catch (error) {
      if (error instanceof ValidationError) {
        return callback(new Error(error.toStringFormatted()));
      }
      if (!(error instanceof Error)) throw error;
      const fpath = import_node_path.default.relative(this.context, this.resourcePath);
      error.message = `${fpath}:${error.name}: ${error.message}`;
      callback(error);
    }
  };
}

// src/core.ts
var import_node_path2 = __toESM(require("path"), 1);
var import_promises2 = __toESM(require("fs/promises"), 1);
function createCore(options, defaultPlugins = []) {
  let config;
  let plugins2;
  return {
    _options: options,
    getPluginContext() {
      return {
        core: this,
        ...options
      };
    },
    /**
     * Convenient cache store, reset when config changes
     */
    cache: /* @__PURE__ */ new Map(),
    async init({ config: newConfig }) {
      config = await newConfig;
      this.cache.clear();
      plugins2 = [];
      for await (const option of [
        ...defaultPlugins,
        ...config.global.plugins ?? []
      ]) {
        if (!option) continue;
        if (Array.isArray(option)) plugins2.push(...option);
        else plugins2.push(option);
      }
      for (const plugin of plugins2) {
        const out = await plugin.config?.call(this.getPluginContext(), config);
        if (out) config = out;
      }
      return this;
    },
    getConfig() {
      return config;
    },
    async initServer(server) {
      for (const plugin of plugins2) {
        await plugin.configureServer?.call(this.getPluginContext(), server);
      }
    },
    async emitAndWrite({
      filterPlugin = () => true
    } = {}) {
      const start = performance.now();
      const out = await Promise.all(
        plugins2.map((plugin) => {
          if (!filterPlugin(plugin) || !plugin.emit) return [];
          return plugin.emit.call(this.getPluginContext());
        })
      );
      await Promise.all(
        out.flat().map(async (entry) => {
          const file = import_node_path2.default.join(options.outDir, entry.path);
          await import_promises2.default.mkdir(import_node_path2.default.dirname(file), { recursive: true });
          await import_promises2.default.writeFile(file, entry.content);
        })
      );
      console.log(`[MDX] generated files in ${performance.now() - start}ms`);
    }
  };
}

// src/loaders/config.ts
var import_promises3 = __toESM(require("fs/promises"), 1);
function createStandaloneConfigLoader({
  core,
  buildConfig: buildConfig2,
  mode
}) {
  let loaded;
  async function getConfigHash() {
    if (mode === "production") return "static";
    const stats = await import_promises3.default.stat(core._options.configPath).catch(() => {
      throw new Error("Cannot find config file");
    });
    return stats.mtime.getTime().toString();
  }
  async function newConfig() {
    const { loadConfig: loadConfig2 } = await Promise.resolve().then(() => (init_load_from_file(), load_from_file_exports));
    await core.init({
      config: loadConfig2(
        core._options.configPath,
        core._options.outDir,
        buildConfig2
      )
    });
    return core.getConfig();
  }
  return {
    async getConfig() {
      const hash = await getConfigHash();
      if (loaded && loaded.hash === hash) return loaded.config;
      loaded = {
        hash,
        config: newConfig()
      };
      return loaded.config;
    }
  };
}

// src/loaders/meta.ts
var import_js_yaml = require("js-yaml");
var import_zod = require("zod");

// src/loaders/index.ts
var metaLoaderGlob = /\.(json|yaml)(\?.+?)?$/;

// src/loaders/meta.ts
var querySchema = import_zod.z.object({
  collection: import_zod.z.string().optional()
}).loose();
function createMetaLoader(configLoader, resolve2 = {}) {
  const { json: resolveJson = "js", yaml: resolveYaml = "js" } = resolve2;
  function stringifyOutput(isJson, data) {
    if (isJson) {
      return resolveJson === "json" ? JSON.stringify(data) : `export default ${JSON.stringify(data)}`;
    } else {
      return resolveYaml === "yaml" ? (0, import_js_yaml.dump)(data) : `export default ${JSON.stringify(data)}`;
    }
  }
  return {
    test: metaLoaderGlob,
    async load({ filePath, query, getSource }) {
      const parsed = querySchema.parse(query);
      const collection = parsed.collection ? (await configLoader.getConfig()).getCollection(parsed.collection) : void 0;
      if (!collection) return null;
      const isJson = filePath.endsWith(".json");
      const source = await getSource();
      let data;
      try {
        data = isJson ? JSON.parse(source) : (0, import_js_yaml.load)(source);
      } catch (e) {
        throw new Error(`invalid data in ${filePath}`, { cause: e });
      }
      let schema;
      switch (collection?.type) {
        case "meta":
          schema = collection.schema;
          break;
        case "docs":
          schema = collection.meta.schema;
          break;
      }
      if (schema) {
        data = await validate(
          schema,
          data,
          { path: filePath, source },
          `invalid data in ${filePath}`
        );
      }
      return {
        code: stringifyOutput(isJson, data)
      };
    },
    bun: {
      async fallback({ getSource, filePath }) {
        const source = await getSource();
        const isJson = filePath.endsWith(".json");
        let data;
        try {
          data = isJson ? JSON.parse(source) : (0, import_js_yaml.load)(source);
        } catch (e) {
          throw new Error(`invalid data in ${filePath}`, { cause: e });
        }
        return {
          loader: "object",
          exports: data
        };
      }
    }
  };
}

// src/webpack/meta.ts
var instance;
async function loader(source, callback) {
  const { isDev, outDir, configPath } = this.getOptions();
  this.cacheable(true);
  this.addDependency(configPath);
  if (!instance) {
    const core = createCore({
      environment: "webpack",
      outDir,
      configPath
    });
    instance = toWebpack(
      createMetaLoader(
        createStandaloneConfigLoader({
          core,
          buildConfig: false,
          mode: isDev ? "dev" : "production"
        }),
        {
          json: "json",
          yaml: "yaml"
        }
      )
    );
  }
  await instance.call(this, source, callback);
}
