import {
  remarkInclude
} from "./chunk-K5ZLPEIQ.js";

// src/loaders/mdx/build-mdx.ts
import { createProcessor } from "@mdx-js/mdx";

// src/loaders/mdx/remark-postprocess.ts
import { visit } from "unist-util-visit";
import { toMarkdown } from "mdast-util-to-markdown";
import { valueToEstree } from "estree-util-value-to-estree";
import { removePosition } from "unist-util-remove-position";
import remarkMdx from "remark-mdx";
function remarkPostprocess({
  _format,
  includeProcessedMarkdown = false,
  includeMDAST = false,
  valueToExport = []
}) {
  let _stringifyProcessor;
  const getStringifyProcessor = () => {
    if (_format === "mdx") return this;
    return _stringifyProcessor ??= this().use(remarkMdx).freeze();
  };
  return (tree, file) => {
    let title;
    const urls = [];
    visit(tree, ["heading", "link"], (node) => {
      if (node.type === "heading" && node.depth === 1) {
        title = flattenNode(node);
      }
      if (node.type !== "link") return;
      urls.push({
        href: node.url
      });
      return "skip";
    });
    if (title) {
      file.data.frontmatter ??= {};
      if (!file.data.frontmatter.title) file.data.frontmatter.title = title;
    }
    file.data.extractedReferences = urls;
    if (includeProcessedMarkdown) {
      const processor = getStringifyProcessor();
      file.data._markdown = toMarkdown(tree, {
        ...processor.data("settings"),
        // from https://github.com/remarkjs/remark/blob/main/packages/remark-stringify/lib/index.js
        extensions: processor.data("toMarkdownExtensions") || []
      });
    }
    if (includeMDAST) {
      const options = includeMDAST === true ? {} : includeMDAST;
      file.data._mdast = JSON.stringify(
        options.removePosition ? removePosition(structuredClone(tree)) : tree
      );
    }
    for (const { name, value } of file.data["mdx-export"] ?? []) {
      tree.children.unshift(getMdastExport(name, value));
    }
    for (const name of valueToExport) {
      if (!(name in file.data)) continue;
      tree.children.unshift(getMdastExport(name, file.data[name]));
    }
  };
}
function getMdastExport(name, value) {
  return {
    type: "mdxjsEsm",
    value: "",
    data: {
      estree: {
        type: "Program",
        sourceType: "module",
        body: [
          {
            type: "ExportNamedDeclaration",
            attributes: [],
            specifiers: [],
            source: null,
            declaration: {
              type: "VariableDeclaration",
              kind: "let",
              declarations: [
                {
                  type: "VariableDeclarator",
                  id: {
                    type: "Identifier",
                    name
                  },
                  init: valueToEstree(value)
                }
              ]
            }
          }
        ]
      }
    }
  };
}
function flattenNode(node) {
  if ("children" in node)
    return node.children.map((child) => flattenNode(child)).join("");
  if ("value" in node) return node.value;
  return "";
}

// src/loaders/mdx/build-mdx.ts
var cache = /* @__PURE__ */ new Map();
async function buildMDX(cacheKey, source, options) {
  const { filePath, frontmatter, data, _compiler, ...rest } = options;
  function getProcessor(format) {
    const key = `${cacheKey}:${format}`;
    let processor = cache.get(key);
    if (!processor) {
      processor = createProcessor({
        outputFormat: "program",
        ...rest,
        remarkPlugins: [
          remarkInclude,
          ...rest.remarkPlugins ?? [],
          [
            remarkPostprocess,
            {
              _format: format,
              ...options.postprocess,
              valueToExport: [
                ...options.postprocess?.valueToExport ?? [],
                "structuredData",
                "extractedReferences",
                "frontmatter",
                "lastModified",
                "_markdown",
                "_mdast"
              ]
            }
          ]
        ],
        format
      });
      cache.set(key, processor);
    }
    return processor;
  }
  return getProcessor(
    options.format ?? (filePath.endsWith(".mdx") ? "mdx" : "md")
  ).process({
    value: source,
    path: filePath,
    data: {
      ...data,
      frontmatter,
      _compiler,
      _getProcessor: getProcessor
    }
  });
}

export {
  buildMDX
};
