// src/utils/validation.ts
import picocolors from "picocolors";
var ValidationError = class extends Error {
  constructor(message, issues) {
    super(
      `${message}:
${issues.map((issue) => `  ${issue.path}: ${issue.message}`).join("\n")}`
    );
    this.title = message;
    this.issues = issues;
  }
  toStringFormatted() {
    return [
      picocolors.bold(`[MDX] ${this.title}:`),
      ...this.issues.map(
        (issue) => picocolors.redBright(
          `- ${picocolors.bold(issue.path?.join(".") ?? "*")}: ${issue.message}`
        )
      )
    ].join("\n");
  }
};
async function validate(schema, data, context, errorMessage) {
  if (typeof schema === "function" && !("~standard" in schema)) {
    schema = schema(context);
  }
  if ("~standard" in schema) {
    const result = await schema["~standard"].validate(
      data
    );
    if (result.issues) {
      throw new ValidationError(errorMessage, result.issues);
    }
    return result.value;
  }
  return data;
}

// src/core.ts
import path from "path";
import fs from "fs/promises";
function findConfigFile() {
  return path.resolve("source.config.ts");
}
function createCore(options, defaultPlugins = []) {
  let config;
  let plugins;
  return {
    _options: options,
    getPluginContext() {
      return {
        core: this,
        ...options
      };
    },
    /**
     * Convenient cache store, reset when config changes
     */
    cache: /* @__PURE__ */ new Map(),
    async init({ config: newConfig }) {
      config = await newConfig;
      this.cache.clear();
      plugins = [];
      for await (const option of [
        ...defaultPlugins,
        ...config.global.plugins ?? []
      ]) {
        if (!option) continue;
        if (Array.isArray(option)) plugins.push(...option);
        else plugins.push(option);
      }
      for (const plugin of plugins) {
        const out = await plugin.config?.call(this.getPluginContext(), config);
        if (out) config = out;
      }
      return this;
    },
    getConfig() {
      return config;
    },
    async initServer(server) {
      for (const plugin of plugins) {
        await plugin.configureServer?.call(this.getPluginContext(), server);
      }
    },
    async emitAndWrite({
      filterPlugin = () => true
    } = {}) {
      const start = performance.now();
      const out = await Promise.all(
        plugins.map((plugin) => {
          if (!filterPlugin(plugin) || !plugin.emit) return [];
          return plugin.emit.call(this.getPluginContext());
        })
      );
      await Promise.all(
        out.flat().map(async (entry) => {
          const file = path.join(options.outDir, entry.path);
          await fs.mkdir(path.dirname(file), { recursive: true });
          await fs.writeFile(file, entry.content);
        })
      );
      console.log(`[MDX] generated files in ${performance.now() - start}ms`);
    }
  };
}

// src/loaders/index.ts
var metaLoaderGlob = /\.(json|yaml)(\?.+?)?$/;
var mdxLoaderGlob = /\.mdx?(\?.+?)?$/;

export {
  ValidationError,
  validate,
  findConfigFile,
  createCore,
  metaLoaderGlob,
  mdxLoaderGlob
};
