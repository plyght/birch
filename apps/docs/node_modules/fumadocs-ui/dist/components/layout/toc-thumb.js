import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useEffectEvent, useRef, } from 'react';
import { useActiveAnchors } from 'fumadocs-core/toc';
export function TocThumb({ containerRef, ...props }) {
    const thumbRef = useRef(null);
    return (_jsxs(_Fragment, { children: [_jsx("div", { ref: thumbRef, role: "none", ...props }), _jsx(Updater, { containerRef: containerRef, thumbRef: thumbRef })] }));
}
function Updater({ containerRef, thumbRef, }) {
    const active = useActiveAnchors();
    const onPrint = useEffectEvent(() => {
        if (!containerRef.current || !thumbRef.current)
            return;
        update(thumbRef.current, calc(containerRef.current, active));
    });
    useEffect(() => {
        if (!containerRef.current)
            return;
        const container = containerRef.current;
        const observer = new ResizeObserver(onPrint);
        observer.observe(container);
        return () => {
            observer.disconnect();
        };
    }, [containerRef]);
    if (containerRef.current && thumbRef.current) {
        update(thumbRef.current, calc(containerRef.current, active));
    }
    return null;
}
function calc(container, active) {
    if (active.length === 0 || container.clientHeight === 0) {
        return [0, 0];
    }
    let upper = Number.MAX_VALUE, lower = 0;
    for (const item of active) {
        const element = container.querySelector(`a[href="#${item}"]`);
        if (!element)
            continue;
        const styles = getComputedStyle(element);
        upper = Math.min(upper, element.offsetTop + parseFloat(styles.paddingTop));
        lower = Math.max(lower, element.offsetTop +
            element.clientHeight -
            parseFloat(styles.paddingBottom));
    }
    return [upper, lower - upper];
}
function update(element, info) {
    element.style.setProperty('--fd-top', `${info[0]}px`);
    element.style.setProperty('--fd-height', `${info[1]}px`);
}
