// src/mdx-plugins/remark-image.ts
import * as path from "path";
import { visit } from "unist-util-visit";
import { fileURLToPath } from "url";
var VALID_BLUR_EXT = [".jpeg", ".png", ".webp", ".avif", ".jpg"];
var EXTERNAL_URL_REGEX = /^https?:\/\//;
function remarkImage({
  placeholder = "blur",
  external = true,
  useImport = true,
  onError = "error",
  publicDir = path.join(process.cwd(), "public")
} = {}) {
  return async (tree, file) => {
    const importsToInject = [];
    const promises = [];
    async function onImage(src, node) {
      if (src.type === "file" && useImport) {
        const variableName = `__img${importsToInject.length}`;
        const hasBlur = placeholder === "blur" && VALID_BLUR_EXT.some((ext) => src.file.endsWith(ext));
        if (!file.dirname) {
          throw new Error(
            "When `useImport` is enabled, you must specify `dirname` in the VFile passed to compiler."
          );
        }
        importsToInject.push({
          variableName,
          importPath: getImportPath(src.file, file.dirname)
        });
        const out = {
          children: [],
          type: "mdxJsxFlowElement",
          name: "img",
          attributes: [
            {
              type: "mdxJsxAttribute",
              name: "alt",
              value: node.alt ?? "image"
            },
            {
              type: "mdxJsxAttribute",
              name: "src",
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: variableName,
                data: {
                  estree: {
                    body: [
                      {
                        type: "ExpressionStatement",
                        expression: { type: "Identifier", name: variableName }
                      }
                    ],
                    type: "Program",
                    sourceType: "script"
                  }
                }
              }
            }
          ]
        };
        if (hasBlur) {
          out.attributes.push({
            type: "mdxJsxAttribute",
            name: "placeholder",
            value: "blur"
          });
        }
        return out;
      }
      const size = await getImageSize(src, external).catch((e) => {
        throw new Error(
          `[Remark Image] Failed obtain image size for ${node.url} (public directory configured as ${publicDir})`,
          {
            cause: e
          }
        );
      });
      if (!size) return;
      return {
        type: "mdxJsxFlowElement",
        name: "img",
        attributes: [
          {
            type: "mdxJsxAttribute",
            name: "alt",
            value: node.alt ?? "image"
          },
          {
            type: "mdxJsxAttribute",
            name: "src",
            // `src` doesn't support file paths, we can use `node.url` for files and let the underlying framework handle it
            value: src.type === "url" ? src.url.toString() : node.url
          },
          {
            type: "mdxJsxAttribute",
            name: "width",
            value: size.width.toString()
          },
          {
            type: "mdxJsxAttribute",
            name: "height",
            value: size.height.toString()
          }
        ],
        children: []
      };
    }
    visit(tree, "image", (node) => {
      const src = parseSrc(decodeURI(node.url), publicDir, file.dirname);
      if (!src) return;
      const task = onImage(src, node).catch((e) => {
        if (onError === "ignore" || node.url.endsWith(".svg")) {
          return;
        }
        if (onError === "hide") {
          return {
            type: "mdxJsxFlowElement",
            name: null,
            attributes: [],
            children: []
          };
        }
        if (onError === "error") throw e;
        onError(e);
      }).then((res) => {
        if (res) Object.assign(node, res);
      });
      promises.push(task);
    });
    await Promise.all(promises);
    if (importsToInject.length === 0) return;
    const imports = importsToInject.map(
      ({ variableName, importPath }) => ({
        type: "mdxjsEsm",
        data: {
          estree: {
            body: [
              {
                type: "ImportDeclaration",
                source: { type: "Literal", value: importPath },
                specifiers: [
                  {
                    type: "ImportDefaultSpecifier",
                    local: { type: "Identifier", name: variableName }
                  }
                ]
              }
            ]
          }
        }
      })
    );
    tree.children.unshift(...imports);
  };
}
function getImportPath(file, dir) {
  const relative2 = path.relative(dir, file).replaceAll(path.sep, "/");
  return relative2.startsWith("../") ? relative2 : `./${relative2}`;
}
function parseSrc(src, publicDir, dir) {
  if (src.startsWith("file:///"))
    return { type: "file", file: fileURLToPath(src) };
  if (EXTERNAL_URL_REGEX.test(src)) {
    return {
      type: "url",
      url: new URL(src)
    };
  }
  if (src.startsWith("/")) {
    if (EXTERNAL_URL_REGEX.test(publicDir)) {
      const url = new URL(publicDir);
      const segs = [...url.pathname.split("/"), ...src.split("/")].filter(
        (v) => v.length > 0
      );
      url.pathname = `/${segs.join("/")}`;
      return { type: "url", url };
    }
    return {
      type: "file",
      file: path.join(publicDir, src)
    };
  }
  if (!dir) {
    console.warn(
      `[Remark Image] found relative path ${src} but missing 'dirname' in VFile, this image will be skipped for now.`
    );
    return;
  }
  return {
    type: "file",
    file: path.join(dir, src)
  };
}
async function getImageSize(src, onExternal) {
  if (src.type === "file") {
    const { imageSizeFromFile } = await import("image-size/fromFile");
    return imageSizeFromFile(src.file);
  }
  if (onExternal === false) return;
  const { timeout } = typeof onExternal === "object" ? onExternal : {};
  const res = await fetch(src.url, {
    signal: typeof timeout === "number" ? AbortSignal.timeout(timeout) : void 0
  });
  if (!res.ok) {
    throw new Error(
      `[Remark Image] Failed to fetch ${src.url} (${res.status}): ${await res.text()}`
    );
  }
  const { imageSize } = await import("image-size");
  return imageSize(new Uint8Array(await res.arrayBuffer()));
}

export {
  remarkImage
};
