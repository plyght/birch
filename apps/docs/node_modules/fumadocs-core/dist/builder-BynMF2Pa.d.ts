import { R as Root, I as Item, F as Folder, S as Separator } from './definitions-DQnHJeWn.js';
import { I18nConfig } from './i18n/index.js';
import { ReactNode } from 'react';

interface LoaderPlugin<Page extends PageData = PageData, Meta extends MetaData = MetaData> {
    name?: string;
    /**
     * Change the order of plugin:
     * - `pre`: before normal plugins
     * - `post`: after normal plugins
     */
    enforce?: 'pre' | 'post';
    /**
     * receive & replace loader options
     */
    config?: (config: ResolvedLoaderConfig) => ResolvedLoaderConfig | void | undefined;
    /**
     * transform the storage after loading
     */
    transformStorage?: (context: {
        storage: ContentStorage<Page, Meta>;
    }) => void;
    /**
     * transform the generated page tree
     */
    transformPageTree?: PageTreeTransformer<Page, Meta>;
}
declare function buildPlugins(plugins: (LoaderPlugin | LoaderPlugin[] | undefined)[]): LoaderPlugin[];

type IconResolver = (icon: string | undefined) => ReactNode;

interface LoaderConfig {
    source: SourceConfig;
    i18n: I18nConfig | undefined;
}
interface SourceConfig {
    pageData: PageData;
    metaData: MetaData;
}
interface LoaderOptions<S extends SourceConfig = SourceConfig, I18n extends I18nConfig | undefined = I18nConfig | undefined> {
    baseUrl: string;
    i18n?: I18n;
    url?: UrlFn;
    /**
     * Additional options for page tree builder
     */
    pageTree?: PageTreeOptions<S['pageData'], S['metaData']>;
    plugins?: (LoaderPlugin<S['pageData'], S['metaData']> | LoaderPlugin<S['pageData'], S['metaData']>[] | undefined)[];
    icon?: IconResolver;
    slugs?: (info: {
        path: string;
    }) => string[];
}
interface ResolvedLoaderConfig {
    source: Source;
    url: UrlFn;
    plugins?: LoaderPlugin[];
    pageTree?: PageTreeOptions;
    i18n?: I18nConfig | undefined;
}
interface Source<Config extends SourceConfig = SourceConfig> {
    files: VirtualFile<Config>[];
}
interface SharedFileInfo {
    /**
     * Virtualized file path (relative to content directory)
     *
     * @example `docs/page.mdx`
     */
    path: string;
    /**
     * Absolute path of the file (can be empty)
     */
    absolutePath: string;
}
interface Page<Data = PageData> extends SharedFileInfo {
    slugs: string[];
    url: string;
    data: Data;
    locale?: string | undefined;
}
interface Meta<Data = MetaData> extends SharedFileInfo {
    data: Data;
}
interface LoaderOutput<Config extends LoaderConfig> {
    pageTree: Config['i18n'] extends I18nConfig ? Record<string, Root> : Root;
    getPageTree: (locale?: string) => Root;
    getPageByHref: (href: string, options?: {
        language?: string;
        /**
         * resolve relative file paths in `href` from specified dirname, must be a virtual path.
         */
        dir?: string;
    }) => {
        page: Page<Config['source']['pageData']>;
        hash?: string;
    } | undefined;
    /**
     * @internal
     */
    _i18n?: I18nConfig;
    /**
     * Get a list of pages from specified language
     *
     * @param language - If empty, list pages from all languages.
     */
    getPages: (language?: string) => Page<Config['source']['pageData']>[];
    /**
     * get each language and its pages, empty if i18n is not enabled.
     */
    getLanguages: () => {
        language: string;
        pages: Page<Config['source']['pageData']>[];
    }[];
    /**
     * Get page with slugs
     *
     * @param language - If empty, the default language will be used
     */
    getPage: (slugs: string[] | undefined, language?: string) => Page<Config['source']['pageData']> | undefined;
    getNodePage: (node: Item, language?: string) => Page<Config['source']['pageData']> | undefined;
    getNodeMeta: (node: Folder, language?: string) => Meta<Config['source']['metaData']> | undefined;
    /**
     * generate static params for Next.js SSG
     *
     * @param slug - customise parameter name for slugs
     * @param lang - customise parameter name for lang
     */
    generateParams: <TSlug extends string = 'slug', TLang extends string = 'lang'>(slug?: TSlug, lang?: TLang) => (Record<TSlug, string[]> & Record<TLang, string>)[];
}
declare function createGetUrl(baseUrl: string, i18n?: I18nConfig): UrlFn;
declare function loader<Config extends SourceConfig, I18n extends I18nConfig | undefined = undefined>(source: Source<Config>, options: LoaderOptions<NoInfer<Config>, I18n>): LoaderOutput<{
    source: Config;
    i18n: I18n;
}>;
declare function loader<Config extends SourceConfig, I18n extends I18nConfig | undefined = undefined>(options: LoaderOptions<NoInfer<Config>, I18n> & {
    source: Source<Config>;
}): LoaderOutput<{
    source: Config;
    i18n: I18n;
}>;
type _ConfigUnion_<T extends Record<string, Source>> = {
    [K in keyof T]: T[K] extends Source<infer Config> ? {
        pageData: Config['pageData'] & {
            type: K;
        };
        metaData: Config['metaData'] & {
            type: K;
        };
    } : never;
}[keyof T];
declare function multiple<T extends Record<string, Source>>(sources: T): Source<_ConfigUnion_<T>>;
/**
 * map virtual files in source
 */
declare function map<Config extends SourceConfig>(source: Source<Config>): {
    page<$Page extends PageData>(fn: (entry: VirtualPage<Config["pageData"]>) => VirtualPage<$Page>): Source<{
        pageData: $Page;
        metaData: Config["metaData"];
    }>;
    meta<$Meta extends MetaData>(fn: (entry: VirtualMeta<Config["metaData"]>) => VirtualMeta<$Meta>): Source<{
        pageData: Config["pageData"];
        metaData: $Meta;
    }>;
};

interface MetaData {
    icon?: string | undefined;
    title?: string | undefined;
    root?: boolean | undefined;
    pages?: string[] | undefined;
    defaultOpen?: boolean | undefined;
    description?: string | undefined;
}
interface PageData {
    icon?: string | undefined;
    title?: string;
    description?: string | undefined;
}
interface BaseVirtualFile {
    /**
     * Virtualized path (relative to content directory)
     *
     * @example `docs/page.mdx`
     */
    path: string;
    /**
     * Absolute path of the file
     */
    absolutePath?: string;
}
interface VirtualPage<Data extends PageData> extends BaseVirtualFile {
    type: 'page';
    /**
     * Specified Slugs for page
     */
    slugs?: string[];
    data: Data;
}
interface VirtualMeta<Data extends MetaData> extends BaseVirtualFile {
    type: 'meta';
    data: Data;
}
type VirtualFile<Config extends SourceConfig = SourceConfig> = VirtualPage<Config['pageData']> | VirtualMeta<Config['metaData']>;
type InferPageType<Utils extends LoaderOutput<any>> = Utils extends LoaderOutput<infer Config> ? Page<Config['source']['pageData']> : never;
type InferMetaType<Utils extends LoaderOutput<any>> = Utils extends LoaderOutput<infer Config> ? Meta<Config['source']['metaData']> : never;
/**
 * @internal
 */
type UrlFn = (slugs: string[], locale?: string) => string;

/**
 * In memory file system.
 */
declare class FileSystem<File> {
    files: Map<string, File>;
    folders: Map<string, string[]>;
    constructor(inherit?: FileSystem<File>);
    read(path: string): File | undefined;
    /**
     * get the direct children of folder (in virtual file path)
     */
    readDir(path: string): string[] | undefined;
    write(path: string, file: File): void;
    /**
     * Delete files at specified path.
     *
     * @param path - the target path.
     * @param [recursive=false] - if set to `true`, it will also delete directories.
     */
    delete(path: string, recursive?: boolean): boolean;
    getFiles(): string[];
    makeDir(path: string): void;
}

type ContentStorage<Page extends PageData = PageData, Meta extends MetaData = MetaData> = FileSystem<MetaFile<Meta> | PageFile<Page>>;
interface MetaFile<Data extends MetaData = MetaData> {
    path: string;
    absolutePath: string;
    format: 'meta';
    data: Data;
}
interface PageFile<Data extends PageData = PageData> {
    path: string;
    absolutePath: string;
    format: 'page';
    slugs: string[];
    data: Data;
}

interface PageTreeBuilderContext<Page extends PageData = PageData, Meta extends MetaData = MetaData> {
    /**
     * @internal resolve paths without extensions
     */
    resolveName: (name: string, format: 'meta' | 'page') => string;
    options: PageTreeOptions;
    transformers: PageTreeTransformer<Page, Meta>[];
    builder: PageTreeBuilder;
    storage: ContentStorage<Page, Meta>;
    getUrl: UrlFn;
    storages?: Record<string, ContentStorage<Page, Meta>>;
    locale?: string;
    visitedPaths: Set<string>;
}
interface PageTreeTransformer<Page extends PageData = PageData, Meta extends MetaData = MetaData> {
    file?: (this: PageTreeBuilderContext<Page, Meta>, node: Item, filePath?: string) => Item;
    folder?: (this: PageTreeBuilderContext<Page, Meta>, node: Folder, folderPath: string, metaPath?: string) => Folder;
    separator?: (this: PageTreeBuilderContext<Page, Meta>, node: Separator) => Separator;
    root?: (this: PageTreeBuilderContext<Page, Meta>, node: Root) => Root;
}
interface PageTreeOptions<Page extends PageData = PageData, Meta extends MetaData = MetaData> {
    id?: string;
    /**
     * Remove references to the file path of original nodes (`$ref`)
     *
     * @defaultValue false
     */
    noRef?: boolean;
    /**
     * generate fallback page tree
     *
     * @defaultValue true
     */
    generateFallback?: boolean;
    /**
     * Additional page tree transformers to apply
     */
    transformers?: PageTreeTransformer<Page, Meta>[];
}
interface PageTreeBuilder {
    build: (storage: ContentStorage, options?: PageTreeOptions) => Root;
    buildI18n: (storages: Record<string, ContentStorage>, options?: PageTreeOptions) => Record<string, Root>;
}
declare function createPageTreeBuilder(getUrl: UrlFn, plugins?: LoaderPlugin[]): PageTreeBuilder;

export { type ContentStorage as C, FileSystem as F, type InferPageType as I, type LoaderPlugin as L, type MetaFile as M, type PageTreeTransformer as P, type ResolvedLoaderConfig as R, type SourceConfig as S, type UrlFn as U, type VirtualPage as V, type _ConfigUnion_ as _, type PageTreeBuilder as a, type PageTreeBuilderContext as b, createPageTreeBuilder as c, type PageTreeOptions as d, type PageFile as e, type LoaderConfig as f, type LoaderOptions as g, type Source as h, type Page as i, type Meta as j, type LoaderOutput as k, createGetUrl as l, loader as m, multiple as n, map as o, type MetaData as p, type PageData as q, type VirtualMeta as r, type VirtualFile as s, type InferMetaType as t, buildPlugins as u };
